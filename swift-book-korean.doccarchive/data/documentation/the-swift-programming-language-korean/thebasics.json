{"schemaVersion":{"minor":3,"patch":0,"major":0},"sections":[],"primaryContentSections":[{"content":[{"inlineContent":[{"text":"Swift는 iOS, macOS, watchOS, 그리고 tvOS app 개발을 위한 프로그래밍 언어입니다. C 또는 Objective-C 의 개발경험을 가지고 있다면 Swift 의 많은 부분이 유사할 것입니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift는 정수 (integer)에 대한 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":", 부동 소수점 (floating-point)에 대한 "},{"code":"Double","type":"codeVoice"},{"text":" 및 ","type":"text"},{"code":"Float","type":"codeVoice"},{"type":"text","text":", 부울 (Boolean) 값에 대한 "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" 및 텍스트 데이터에 대한 "},{"type":"codeVoice","code":"String"},{"text":"을 포함하여 C와 Objective-C 모든 기초 타입을 자체 버전에 맞게 제공합니다. Swift는 또한 ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes","isActive":true},{"text":"에서 자세히 다룰 ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Set"},{"text":", 그리고 ","type":"text"},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" 인 3개의 기본 콜렉션 타입을 제공합니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"C와 마찬가지로 Swift는 변수를 식별 가능한 이름으로 값을 저장하고 참조합니다. Swift는 또한 값을 변경할 수 없는 변수를 광범위하게 사용합니다. 이러한 변수를 상수라고 하며 C에서의 상수보다 훨씬 더 강력합니다. 상수는 Swift 전체에서 사용되며 변경할 필요가 없는 값으로 작업할 때 코드를 보다 안전하고 명확하게 만들 수 있습니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"익숙한 타입 외에도 Swift는 Objective-C에는 없는 튜플 (tuple)이라는 고급 타입이 있습니다. 튜플은 값을 그룹화 하여 생성하거나 전달할 수 있습니다. 튜플을 사용하여 함수의 여러값을 단일 복합 값으로 반환할 수 있습니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 또한 값이 존재하지 않는 상태를 처리하기 위해 옵셔널 (Optional) 타입이 있습니다. 옵셔널은 "},{"type":"emphasis","inlineContent":[{"text":"“값이 있고 x와 같다”","type":"text"}]},{"type":"text","text":" 또는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"“값이 없다”"}]},{"text":" 를 알려줍니다.","type":"text"}]},{"inlineContent":[{"text":"Swift는 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"타입-세이프 (type-safe)"}]},{"type":"text","text":" 언어입니다. 타입 세이프란 언어가 값에 대해 타입을 명확하도록 도와주고 코드에서 같이 동작할 수 있도록 해줍니다. 타입 세이프티는 만약 "},{"code":"String","type":"codeVoice"},{"text":"을 요구하는 코드에서 실수로 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":"로 전달하는 것을 막아줍니다. 마찬가지로 옵셔널이 아닌 "},{"code":"String","type":"codeVoice"},{"type":"text","text":"을 요구하는 코드에 옵셔널 "},{"type":"codeVoice","code":"String"},{"type":"text","text":"을 전달하는 것을 막아줍니다. 타입 세이프티는 개발 단계에서 가능한 빠르게 에러를 찾고 고칠 수 있게 도와줍니다."}],"type":"paragraph"},{"type":"heading","text":"상수와 변수 (Constants and Variables)","level":2,"anchor":"상수와-변수-Constants-and-Variables"},{"inlineContent":[{"text":"상수와 변수는 이름 (","type":"text"},{"type":"codeVoice","code":"maximumNumberOfLoginAttempts"},{"text":" 또는 ","type":"text"},{"type":"codeVoice","code":"welcomeMessage"},{"type":"text","text":")과 특정 타입 (숫자 "},{"code":"10","type":"codeVoice"},{"text":" 또는 문자열 ","type":"text"},{"type":"codeVoice","code":"\"Hello\""},{"type":"text","text":"와 같은 타입)의 값을 연결합니다. "},{"inlineContent":[{"text":"상수 (Constant)","type":"text"}],"type":"emphasis"},{"text":" 의 값은 최초 지정 후 변경이 불가능하지만 ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"변수 (Variable)","type":"text"}]},{"text":" 는 다른 값으로 변경이 가능합니다.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"상수와 변수 선언 (Declaring Constants and Variables)","anchor":"상수와-변수-선언-Declaring-Constants-and-Variables","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"상수와 변수는 사용하기 전에 반드시 선언이 되어야 합니다. 상수는 "},{"type":"codeVoice","code":"let"},{"text":" 키워드와 함께 선언하고 변수는 ","type":"text"},{"code":"var","type":"codeVoice"},{"type":"text","text":" 키워드와 함께 선언합니다. 다음의 예제는 상수와 변수를 사용하여 어떻게 사용자 로그인 시도 횟수를 추적하는지를 보여줍니다:"}]},{"syntax":"swift","code":["let maximumNumberOfLoginAttempts = 10","var currentLoginAttempt = 0"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"이 코드는 아래와 같이 읽을 수 있습니다:"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"”"},{"type":"codeVoice","code":"maximumNumberOfLoginAttempts"},{"text":" 인 새로운 상수를 선언하고 ","type":"text"},{"type":"codeVoice","code":"10"},{"text":" 이라는 값을 설정합니다. 그리고 ","type":"text"},{"type":"codeVoice","code":"currentLoginAttempt"},{"text":" 인 새로운 변수를 선언하고 ","type":"text"},{"type":"codeVoice","code":"0"},{"type":"text","text":" 이라는 값으로 초기화 하였습니다.”"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제에서 최대 로그인 시도 횟수는 최대값은 절대 변경되지 않아야 하므로 상수로 선언하였습니다. 현재 로그인 시도 횟수는 로그인 실패 시 값을 증가시켜야 하므로 변수로 선언하였습니다."}]},{"inlineContent":[{"text":"코드에서 저장된 값이 변경되지 않으면,","type":"text"},{"text":" ","type":"text"},{"code":"let","type":"codeVoice"},{"type":"text","text":" 키워드로 상수로 선언합니다."},{"text":" ","type":"text"},{"type":"text","text":"변경되는 값을 저장하기 위해 변수를 사용합니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"상수 또는 변수로 선언할 때,"},{"type":"text","text":" "},{"type":"text","text":"위의 예제처럼"},{"text":" ","type":"text"},{"text":"선언의 부분으로 값을 줄 수 있습니다.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"또는"},{"text":" ","type":"text"},{"type":"text","text":"처음 값을 읽기 전에"},{"text":" ","type":"text"},{"type":"text","text":"값의 존재가 보장되면"},{"type":"text","text":" "},{"type":"text","text":"프로그램에 마지막에 초기화 값을 할당할 수 있습니다."}],"type":"paragraph"},{"syntax":"swift","code":["var environment = \"development\"","let maximumNumberOfLoginAttempts: Int","\/\/ maximumNumberOfLoginAttempts has no value yet.","","if environment == \"development\" {","    maximumNumberOfLoginAttempts = 100","} else {","    maximumNumberOfLoginAttempts = 10","}","\/\/ Now maximumNumberOfLoginAttempts has a value, and can be read."],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제에서,"},{"text":" ","type":"text"},{"type":"text","text":"로그인 시도 최대횟수는 상수이고,"},{"type":"text","text":" "},{"text":"이 값은 환경에 의존합니다.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"개발 환경에서는"},{"text":" ","type":"text"},{"text":"100의 값을 가지고;","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"다른 환경에서는 10을 가집니다."},{"text":" ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 각 조건에서"},{"type":"text","text":" "},{"type":"text","text":"어떠한 값으로 "},{"code":"maximumNumberOfLoginAttempts","type":"codeVoice"},{"text":" 을 초기화하고,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"이 상수는 항상 값이 있음을 보장합니다."},{"text":" ","type":"text"},{"text":"이 방법으로 초기값을 설정할 때,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift 가 어떻게 코드를 검사하는지 자세한 내용은"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EC%83%81%EC%88%98-%EC%84%A0%EC%96%B8-Constant-Declaration","isActive":true},{"text":" 을 참고 바랍니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"여러개의 상수 또는 여러개의 변수를 선언할 때 콤마로 구분하여 한줄로 선언이 가능합니다:","type":"text"}]},{"code":["var x = 0.0, y = 0.0, z = 0.0"],"syntax":"swift","type":"codeListing"},{"anchor":"타입-명시-Type-Annotations","text":"타입 명시 (Type Annotations)","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"상수 또는 변수를 선언할 때 저장할 수 있는 값의 종류를 명확하게 하기위해 ","type":"text"},{"inlineContent":[{"text":"타입 명시 (Type Annotation)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 를 제공할 수 있습니다. 타입 명시는 상수 또는 변수 이름 뒤에 콜론과 공백 한칸 뒤에 사용할 타입 이름을 적어 사용합니다."}]},{"inlineContent":[{"text":"이 예제는 ","type":"text"},{"type":"codeVoice","code":"welcomeMessage"},{"text":" 라는 변수에 ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" 값을 저장할 수 있는 변수를 나타내는 타입 명시를 제공합니다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var welcomeMessage: String"]},{"type":"paragraph","inlineContent":[{"text":"위 코드에서 선언에 있는 콜론은 “…의 타입은…” 을 의미하므로 아래와 같이 읽을 수 있습니다:","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"“선언한 변수는 "},{"code":"welcomeMessage","type":"codeVoice"},{"type":"text","text":" 라고 하며 이것의 타입은 "},{"code":"String","type":"codeVoice"},{"text":" 입니다.”","type":"text"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"“…의 타입은 ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" 입니다.” 라는 의미는 “어떤 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값은 저장 가능합니다.” 입니다. 저장할 수 있는 “어떠한 타입” (또는 “어떠한 종류”) 라고 생각합니다."}]},{"inlineContent":[{"type":"codeVoice","code":"welcomeMessage"},{"type":"text","text":" 변수는 아무런 오류 없이 어떠한 문자열 값을 지정할 수 있습니다:"}],"type":"paragraph"},{"code":["welcomeMessage = \"Hello\""],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"같은 타입에 여러개의 연관된 변수를 콤마로 변수 이름을 구분하고 마지막 변수 이름 뒤에 하나의 타입 명시를 통해 한줄로 선언할 수 있습니다:"}]},{"syntax":"swift","code":["var red, green, blue: Double"],"type":"codeListing"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"Note","type":"text"},{"text":"\n","type":"text"},{"text":"실제로 타입 명시가 필요한 경우는 드뭅니다. 상수 또는 변수를 선언할 때 초기값을 지정하면 Swift는 ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%ED%83%80%EC%9E%85-%EC%84%B8%EC%9D%B4%ED%94%84%ED%8B%B0%EC%99%80-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0-Type-Safety-and-Type-Inference","isActive":true},{"text":" 에서 나와있는대로 해당 상수 또는 변수에 사용될 타입을 거의 항상 유추할 수 있습니다. 위의 ","type":"text"},{"code":"welcomeMessage","type":"codeVoice"},{"type":"text","text":" 예제에서 초기값을 지정하지 않았으므로 "},{"code":"welcomeMessage","type":"codeVoice"},{"type":"text","text":" 변수의 타입은 초기값에서 유추되지 않고 타입을 명시 하였습니다."}]}],"style":"note","name":"Note"},{"text":"상수와 변수의 이름 (Naming Constants and Variables)","level":3,"anchor":"상수와-변수의-이름-Naming-Constants-and-Variables","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"상수와 변수 이름은 유니코드 (Unicode) 문자를 포함하여 대부분의 문자를 포함할 수 있습니다:","type":"text"}]},{"syntax":"swift","code":["let n = 3.14159","let 你好 = \"你好世界\"","let 🐶🐮 = \"dogcow\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"상수와 변수 이름은 공백, 수학적 기호, 화살표, 내부에서 사용하는 유니코드 스칼라 값, 또는 선과 박스를 그리는 문자를 포함할 수 없습니다. 숫자는 이름의 다른곳에는 포함될 수 있지만 숫자로 시작하는 이름은 선언할 수 없습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"특정 타입으로 상수 또는 변수를 선언하면 동일한 이름으로 다시 선언하거나 다른 타입의 값을 저장하도록 변경하여 선언할 수 없습니다. 상수를 변수로 바꾸거나 변수를 상수로 바꿀 수도 없습니다."}]},{"content":[{"inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":"\n"},{"type":"text","text":"Swift 키워드와 동일한 이름의 상수 또는 변수를 제공해야 한다면 이름을 백틱 ("},{"code":"`","type":"codeVoice"},{"text":")으로 묶어야 합니다. 그러나 선택의 여지가 없을때까지는 키워드를 이름으로 사용하지 말아야 합니다.","type":"text"}],"type":"paragraph"}],"name":"Note","style":"note","type":"aside"},{"inlineContent":[{"text":"동일한 타입의 다른 값으로 이미 선언된 변수에 값을 변경할 수 있습니다. 예제에서 ","type":"text"},{"code":"friendlyWelcome","type":"codeVoice"},{"type":"text","text":" 값은 "},{"type":"codeVoice","code":"\"Hello!\""},{"text":" 에서 ","type":"text"},{"type":"codeVoice","code":"\"Bonjour!\""},{"text":" 변경됩니다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var friendlyWelcome = \"Hello!\"","friendlyWelcome = \"Bonjour!\"","\/\/ friendlyWelcome is now \"Bonjour!\""]},{"inlineContent":[{"text":"변수와 달리 상수 값은 지정된 이후에는 변경할 수 없습니다. 값을 변경하려고 하면 코드가 컴파일 될 때 오류가 발생합니다:","type":"text"}],"type":"paragraph"},{"code":["let languageName = \"Swift\"","languageName = \"Swift++\"","\/\/ This is a compile-time error: languageName cannot be changed."],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"상수와-변수-출력-Printing-Constants-and-Variables","text":"상수와 변수 출력 (Printing Constants and Variables)","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"print(_:separator:terminator:)"},{"type":"text","text":" 함수로 상수 또는 변수의 현재 값을 출력할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["print(friendlyWelcome)","\/\/ Prints \"Bonjour!\""]},{"inlineContent":[{"type":"codeVoice","code":"print(_:separator:terminator:)"},{"type":"text","text":" 함수는 하나 또는 그 이상의 값을 적절하게 출력하는 전역 함수입니다. 예를 들어 Xcode에서 "},{"type":"codeVoice","code":"print(_:separator:terminator:)"},{"type":"text","text":" 함수는 Xcode “콘솔 (console)” 창에 결과를 출력합니다. "},{"type":"codeVoice","code":"separator"},{"text":" 와 ","type":"text"},{"code":"terminator","type":"codeVoice"},{"text":" 파라미터는 기본 값을 가지고 있으므로 함수를 호출할 때 생략할 수 있습니다. 기본적으로 이 함수는 줄바꿈을 출력하고 종료됩니다. 줄바꿈 없이 값을 출력하려면 예를 들어 ","type":"text"},{"code":"print(someValue, terminator: \"\")","type":"codeVoice"},{"type":"text","text":" 와 같이 "},{"type":"codeVoice","code":"terminator"},{"type":"text","text":" 에 빈 문자열을 넘겨주면 됩니다. 파라미터 기본값에 대한 자세한 내용은 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EA%B8%B0%EB%B3%B8%EA%B0%92-Default-Parameter-Values","isActive":true},{"type":"text","text":" 을 참고 바랍니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 긴 문자열에 상수 또는 변수의 이름을 포함하여 Swift가 상수 또는 변수의 현재 값으로 대체하기 위해 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"문자열 삽입 (String interpolation)"}]},{"type":"text","text":" 을 사용합니다. 이름을 소괄호로 감싸고 여는 소괄호 전에 역슬래시를 추가해야 합니다:"}]},{"type":"codeListing","code":["print(\"The current value of friendlyWelcome is \\(friendlyWelcome)\")","\/\/ Prints \"The current value of friendlyWelcome is Bonjour!\""],"syntax":"swift"},{"name":"Note","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Note","type":"text"},{"type":"text","text":"\n"},{"text":"문자열 삽입에서 사용할 수 있는 모든 옵션은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/StringsAndCharacters#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%82%BD%EC%9E%85-String-Interpolation","isActive":true,"type":"reference"},{"type":"text","text":" 에 자세히 설명되어 있습니다."}]}]},{"text":"주석 (Comments)","type":"heading","level":2,"anchor":"주석-Comments"},{"type":"paragraph","inlineContent":[{"type":"text","text":"코드에서 설명 또는 기록을 위해 실행되지 않는 문자를 추가할 땐 주석 (Comments)을 사용합니다. 주석은 코드가 컴파일 될 때 Swift 컴파일러에 의해 무시됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서 주석은 C에서 주석을 다는 방법과 유사합니다. 한줄 주석은 두개의 슬래시 ("},{"type":"codeVoice","code":"\/\/"},{"type":"text","text":")로 시작합니다:"}]},{"syntax":"swift","code":["\/\/ This is a comment."],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"여러줄 주석은 슬래시 뒤에 애스터리스크 (","type":"text"},{"code":"\/*","type":"codeVoice"},{"inlineContent":[{"type":"text","text":") 로 시작하고 애스터리스크 뒤에 슬래시 ("},{"code":"*\/","type":"codeVoice"}],"type":"emphasis"},{"text":")로 끝납니다:","type":"text"}]},{"code":["\/* This is also a comment","but is written over multiple lines. *\/"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"C에서 여러줄 주석과 다르게 Swift는 여러줄 주석 안에 다른 여러줄 주석을 통해 중첩시킬 수 있습니다. 여러줄 주석 블럭을 시작한 다음 첫번째 블럭 내에서 두번째 여러줄 주석을 시작하여 중첩된 주석을 작성합니다. 그런다음 두번째 블럭을 닫은 다음 첫번째 블럭을 닫습니다:","type":"text"}]},{"type":"codeListing","code":["\/* This is the start of the first multiline comment."," \/* This is the second, nested multiline comment. *\/","This is the end of the first multiline comment. *\/"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"중첩된 여러줄 주석을 사용하면 코드에 이미 여러줄 주석이 포함되어 있어도 큰 코드 블럭을 빠르고 쉽게 주석 처리할 수 있습니다.","type":"text"}]},{"text":"세미콜론 (Semicolons)","level":2,"anchor":"세미콜론-Semicolons","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"많은 다른 언어와 다르게 Swift는 코드의 각 구문 후에 세미콜론 (","type":"text"},{"type":"codeVoice","code":";"},{"text":")은 필수조건이 아닙니다. 그러나 여러 구문을 한줄로 작성할 경우 세미콜론은 ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"필수로 작성되어야 합니다","type":"text"}]},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let cat = \"🐱\"; print(cat)","\/\/ Prints \"🐱\""]},{"anchor":"정수-Integers","type":"heading","level":2,"text":"정수 (Integers)"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"정수 (Integers)"}]},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"42"},{"text":" 와 ","type":"text"},{"type":"codeVoice","code":"-23"},{"type":"text","text":" 과 같은 분수가 아닌 전체 숫자입니다. 정수는 "},{"inlineContent":[{"text":"부호가 있는 정수 (signed) (양수, 0, 또는 음수)","type":"text"}],"type":"emphasis"},{"text":" 또는 ","type":"text"},{"inlineContent":[{"text":"부호가 없는 정수 (unsigned) (양수 또는 0)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 이 있습니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Swift는 8, 16, 32, 그리고 64 비트 형태의 부호가 있는 정수와 부호가 없는 정수를 지원합니다. 이러한 정수는 8-bit 부호가 없는 정수는 "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" 그리고 32-bit 부호가 있는 정수는 "},{"code":"Int32","type":"codeVoice"},{"type":"text","text":"와 같이 C와 비슷한 네이밍 형태를 가집니다. Swift의 모든 타입과 마찬가지로 정수 타입은 대문자로 시작합니다."}],"type":"paragraph"},{"type":"heading","anchor":"정수-범위-Integer-Bounds","level":3,"text":"정수 범위 (Integer Bounds)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"각 정수 타입의 "},{"code":"min","type":"codeVoice"},{"text":" 과 ","type":"text"},{"type":"codeVoice","code":"max"},{"type":"text","text":" 프로퍼티를 통해 각 정수 타입의 최소값과 최대값을 가져올 수 있습니다:"}]},{"syntax":"swift","type":"codeListing","code":["let minValue = UInt8.min  \/\/ minValue is equal to 0, and is of type UInt8","let maxValue = UInt8.max  \/\/ maxValue is equal to 255, and is of type UInt8"]},{"inlineContent":[{"text":"이러한 프로퍼티의 값은 적절한 크기의 숫자 타입 (위 예에서 ","type":"text"},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":")이므로 동일한 타입의 다른 값과 함께 표현식에 사용될 수 있습니다."}],"type":"paragraph"},{"level":3,"text":"Int","anchor":"Int","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"대부분의 경우 코드에서 사용할 정수의 특정 사이즈를 결정할 필요는 없습니다. Swift는 현재 플랫폼의 네이티브 사이즈와 같은 ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" 인 정수 타입을 제공합니다:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"32-bit 플랫폼에서 "},{"type":"codeVoice","code":"Int"},{"text":" 는 ","type":"text"},{"code":"Int32","type":"codeVoice"},{"text":" 와 같은 크기를 가짐","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"64-bit 플랫폼에서 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 는 "},{"code":"Int64","type":"codeVoice"},{"type":"text","text":" 와 같은 크기를 가짐"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"특정 크기의 정수로 작업해야 하는 경우가 아니라면 항상 코드의 정수 값을 사용할 때 "},{"type":"codeVoice","code":"Int"},{"text":" 를 사용하십시오. 이것은 코드 일관성과 상호 운용성을 지원합니다. 32-bit 플랫폼에서도 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 는 "},{"code":"-2,147,483,648","type":"codeVoice"},{"type":"text","text":" 과 "},{"code":"2,147,483,647","type":"codeVoice"},{"type":"text","text":" 사이의 값을 저장할 수 있으며 일반적인 사용성에 문제가 없습니다."}],"type":"paragraph"},{"text":"UInt","level":3,"type":"heading","anchor":"UInt"},{"inlineContent":[{"text":"Swift는 또한 현재 플랫폼의 네이티브 사이즈와 같은 ","type":"text"},{"code":"UInt","type":"codeVoice"},{"type":"text","text":" 인 정수 타입을 제공합니다:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"32-bit 플랫폼에서 ","type":"text"},{"code":"UInt","type":"codeVoice"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"UInt32"},{"type":"text","text":" 와 같은 크기를 가짐"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"64-bit 플랫폼에서 "},{"type":"codeVoice","code":"UInt"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"UInt64"},{"type":"text","text":" 와 같은 크기를 가짐"}]}]}]},{"style":"note","content":[{"inlineContent":[{"text":"Note","type":"text"},{"text":"\n","type":"text"},{"code":"UInt","type":"codeVoice"},{"type":"text","text":" 는 플랫폼의 네이티브 사이즈와 같은 크기의 부호없는 정수 타입이 필요한 경우에만 사용하십시오. 저장될 값이 음수가 아니어도 "},{"code":"Int","type":"codeVoice"},{"text":" 를 더 선호합니다. 정수값에 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 를 일관되게 사용하면 코드 상호 운용성을 지원하고 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%ED%83%80%EC%9E%85-%EC%84%B8%EC%9D%B4%ED%94%84%ED%8B%B0%EC%99%80-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0-Type-Safety-and-Type-Inference","isActive":true},{"type":"text","text":" 에 설명 된대로 다른 숫자 형식간에 변환 할 필요가 없습니다."}],"type":"paragraph"}],"type":"aside","name":"Note"},{"level":2,"text":"부동 소수점 숫자 (Floating-Point Numbers)","type":"heading","anchor":"부동-소수점-숫자-Floating-Point-Numbers"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"부동 소수점 숫자 (Floating-point numbers)","type":"text"}],"type":"emphasis"},{"text":" 는 ","type":"text"},{"code":"3.14159","type":"codeVoice"},{"type":"text","text":", "},{"code":"0.1","type":"codeVoice"},{"type":"text","text":", 및 "},{"code":"-273.15","type":"codeVoice"},{"type":"text","text":"와 같은 분수 성분을 가진 숫자입니다."}]},{"inlineContent":[{"text":"부동 소수점은 정수 타입의 값 범위보다 더 넓은 범위의 표현이 가능하고 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 보다 더 크거나 작은 값 저장이 가능합니다. Swift는 2개의 부호를 가진 부동 소수점 숫자 타입을 제공합니다:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Double"},{"type":"text","text":" 은 64-bit 부동 소수점 숫자를 표기"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Float"},{"type":"text","text":" 는 32-bit 부동 소수점 숫자를 표기"}]}]}],"type":"unorderedList"},{"content":[{"inlineContent":[{"type":"text","text":"Note"},{"text":"\n","type":"text"},{"type":"codeVoice","code":"Double"},{"text":" 은 최소 15자리의 소수점 정확도를 가지고 있는것에 반해 ","type":"text"},{"code":"Float","type":"codeVoice"},{"text":" 는 더 적은 6자리의 정확도를 가집니다. 사용할 적절한 부동 소수점 타입은 코드에서 작업해야하는 값의 특성과 범위에 따라 다릅니다. 두 타입 중에는 ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" 이 선호됩니다."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"text":"타입 세이프티와 타입 추론 (Type Safety and Type Inference)","level":2,"anchor":"타입-세이프티와-타입-추론-Type-Safety-and-Type-Inference","type":"heading"},{"inlineContent":[{"text":"Swift는 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"타입-세이프 (type-safe)"}]},{"type":"text","text":" 언어입니다. 타입 세이프 언어를 사용하면 코드가 사용할 수 있는 값의 타입을 명확하게 알 수 있습니다. 코드의 일부에서 "},{"code":"String","type":"codeVoice"},{"text":" 이 필요한 경우 실수로 ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" 를 전달할 수 없습니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Swift는 타입 세이프이기 때문에 코드를 컴파일 할 때 타입 검사를 수행하고 일치하지 않는 타입을 오류로 표시합니다. 이를 통해 개발 단계에서 가능한 빨리 오류를 포착하고 수정할 수 있습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"타입 검사는 다른 타입의 값으로 작업할 때 오류를 피하는데 도움이 됩니다. 그러나 이것이 선언하는 모든 상수와 변수의 타입을 지정해야 한다는 것은 아닙니다. 필요한 값의 특정 타입을 지정하지 않으면 Swift는 적절한 타입으로 ","type":"text"},{"inlineContent":[{"text":"타입 추론 (Type Inference)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 을 사용합니다. 타입 추론을 통해 컴파일러는 코드를 컴파일 할 때 제공한 값을 검사하여 특정 식의 타입을 자동으로 추론할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 추론 때문에 Swift는 C 또는 Objective-C와 같은 언어보다 타입 선언을 더 적게 요구됩니다. 상수와 변수는 여전히 명시적으로 타입을 지정하지만 타입을 지정하는 많은 동작을 도와줍니다."}]},{"inlineContent":[{"type":"text","text":"타입 추론은 상수 또는 변수에 초기값을 선언할 때 아주 유용합니다. 이것은 종종 선언하는 시점에 상수 또는 변수에 리터럴 값 (literal value) 또는 리터럴 (literal)을 지정하여 수행됩니다. (리터럴 값은 아래 예에서 42 및 3.14159와 같은 소스 코드에 직접 표시되는 값입니다)"}],"type":"paragraph"},{"inlineContent":[{"text":"예를 들어 어떤 타입인지 선언하지 않고 새로운 상수를 42의 리터럴 값으로 지정하면 Swift는 정수처럼 보이는 숫자로 초기화 했기 때문에 상수가 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 라고 추론합니다:"}],"type":"paragraph"},{"code":["let meaningOfLife = 42","\/\/ meaningOfLife is inferred to be of type Int"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"반대로 어떤 부동 소수점 리터럴의 타입인지 선언하지 않으면 Swift는 "},{"code":"Double","type":"codeVoice"},{"text":" 이라고 추론합니다:","type":"text"}]},{"code":["let pi = 3.14159","\/\/ pi is inferred to be of type Double"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 부동 소수점 숫자의 타입을 추론할 때 항상 "},{"type":"codeVoice","code":"Float"},{"text":" 보다 ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" 을 선택합니다."}]},{"inlineContent":[{"text":"표현식에서 정수와 부동소수 리터럴을 결합하면 컨텍스트에서는 ","type":"text"},{"type":"codeVoice","code":"Double"},{"text":" 타입으로 유추합니다:","type":"text"}],"type":"paragraph"},{"code":["let anotherPi = 3 + 0.14159","\/\/ anotherPi is also inferred to be of type Double"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"code":"3","type":"codeVoice"},{"text":" 인 리터럴 값에는 명시적인 타입이 없으므로 추가로 부동 소수점 리터럴이 존재하는 경우 ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" 이 유추됩니다."}]},{"type":"heading","anchor":"숫자-리터럴-Numeric-Literals","text":"숫자 리터럴 (Numeric Literals)","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"정수 리터럴은 아래와 같이 쓸 수 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"접두사 없는 "},{"inlineContent":[{"text":"10진수","type":"text"}],"type":"emphasis"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"0b"},{"type":"text","text":" 접두사로 "},{"type":"emphasis","inlineContent":[{"text":"2진수","type":"text"}]}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"0o"},{"type":"text","text":" 접두사로 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"8진수"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"0x"},{"text":" 접두사로 ","type":"text"},{"inlineContent":[{"type":"text","text":"16진수"}],"type":"emphasis"}]}]}]},{"inlineContent":[{"type":"text","text":"아래의 예에서 모든 정수 리터럴은 10진수 "},{"type":"codeVoice","code":"17"},{"type":"text","text":" 의 값을 가집니다:"}],"type":"paragraph"},{"code":["let decimalInteger = 17","let binaryInteger = 0b10001       \/\/ 17 in binary notation","let octalInteger = 0o21           \/\/ 17 in octal notation","let hexadecimalInteger = 0x11     \/\/ 17 in hexadecimal notation"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"부동 소수점 리터럴은 10진수 (접두사 없음) 또는 16진수 (접두사 ","type":"text"},{"type":"codeVoice","code":"0x"},{"type":"text","text":") 일 수 있습니다. 소수점 양쪽에 항상 숫자 (또는 16진수)가 있어야 합니다. 10진수는 대문자 또는 소문자 e로 표시되는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"지수"}]},{"text":" 를 가질 수도 있습니다. 16진수는 대문자 또는 소문자 p로 표시되는 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"지수"}]},{"type":"text","text":" 를 가질 수도 있습니다."}]},{"inlineContent":[{"type":"text","text":"지수가 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 인 10진수는 기본 숫자에 10ˣ 가 곱해집니다:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"1.25e2","type":"codeVoice"},{"type":"text","text":" 는 1.25 x 10², 또는 "},{"type":"codeVoice","code":"125.0"}]}]},{"content":[{"inlineContent":[{"code":"1.25e-2","type":"codeVoice"},{"type":"text","text":" 는 1.25 x 10⁻² , 또는 "},{"type":"codeVoice","code":"0.0125"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"지수가 ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" 인 16진수는 기본 숫자에 2ˣ 가 곱해집니다:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"code":"0xFp2","type":"codeVoice"},{"text":" 는 15 x 2² , 또는 ","type":"text"},{"code":"60.0","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"0xFp-2","type":"codeVoice"},{"text":" 는 15 x 2⁻² , 또는 ","type":"text"},{"type":"codeVoice","code":"3.75"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래의 예에서 모든 부동 소수점 리터럴은 10진수 "},{"code":"12.1875","type":"codeVoice"},{"type":"text","text":" 를 가집니다:"}]},{"code":["let decimalDouble = 12.1875","let exponentDouble = 1.21875e1","let hexadecimalDouble = 0xC.3p0"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"숫자 리터럴은 읽기 쉽게 만드는 추가 포맷을 포함할 수 있습니다. 정수와 부동 소수점 모두 추가 0으로 채워질 수 있으며 가독성을 돕기 위해 밑줄을 포함할 수 있습니다. 어떤 형식도 리터럴의 기본 값에 영향을 주지 않습니다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let paddedDouble = 000123.456","let oneMillion = 1_000_000","let justOverOneMillion = 1_000_000.000_000_1"]},{"type":"heading","anchor":"숫자-타입-변환-Numeric-Type-Conversion","level":2,"text":"숫자 타입 변환 (Numeric Type Conversion)"},{"inlineContent":[{"type":"text","text":"음수를 사용하지 않더라도 코드에서 상수와 변수가 정수로 사용이 되면 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 타입을 사용합니다. 일반적인 상황에서 기본 정수 타입을 사용하는 것은 정수 상수와 변수가 코드에서 즉시 상호 운용 가능하며 정수 리터럴 값의 유추 된 타입이 일치한다는 것을 의미합니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"외부 소스에서 명시적으로 크기가 지정된 데이터 또는 성능, 메모리 사용, 또는 다른 성능 최적화를 위해 특별히 필요한 경우에만 다른 정수 타입을 사용하십시오. 이러한 상황에서 명시적으로 크기의 타입을 사용하면 실수로 인한 값 초과를 포착하고 사용중인 데이터의 특성을 알 수 있습니다."}],"type":"paragraph"},{"anchor":"정수-변환-Integer-Conversion","level":3,"text":"정수 변환 (Integer Conversion)","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"정수를 저장할 수 있는 상수 또는 변수의 숫자 범위는 각 숫자 타입에 따라 다릅니다. ","type":"text"},{"code":"Int8","type":"codeVoice"},{"type":"text","text":" 상수 또는 변수는 "},{"code":"-128","type":"codeVoice"},{"type":"text","text":" 과 "},{"type":"codeVoice","code":"127"},{"type":"text","text":" 사이의 숫자를 저장할 수 있는 반면에 "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" 상수 또는 변수는 "},{"code":"0","type":"codeVoice"},{"type":"text","text":" 과 "},{"type":"codeVoice","code":"255"},{"type":"text","text":" 사이의 숫자를 저장할 수 있습니다. 크기가 지정된 정수 타입의 상수 또는 변수에 맞지않는 숫자는 컴파일 시에 오류가 발생합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let cannotBeNegative: UInt8 = -1","\/\/ UInt8 cannot store negative numbers, and so this will report an error","let tooBig: Int8 = Int8.max + 1","\/\/ Int8 cannot store a number larger than its maximum value,","\/\/ and so this will also report an error"]},{"inlineContent":[{"text":"각 숫자 타입은 다른 범위의 값을 저장할 수 있으므로 숫자 타입 변환을 각 타입별로 선택해야 합니다. 이 방식은 숨겨진 변환 오류를 방지하고 코드에서 타입 변환 의도를 명시적으로 만드는데 도움을 줍니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"특정 숫자 타입을 다른 숫자 타입으로 변환하려면 기존값으로 원하는 타입의 새 숫자를 초기화합니다. 아래의 예제에서 상수 "},{"type":"codeVoice","code":"twoThousand"},{"text":" 는 ","type":"text"},{"code":"UInt16","type":"codeVoice"},{"text":" 타입인 반면에 상수 ","type":"text"},{"code":"one","type":"codeVoice"},{"type":"text","text":" 은 "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" 타입입니다. 두 상수는 타입이 다르기 때문에 직접 더할 수 없습니다. 대신 이 예제에서 "},{"type":"codeVoice","code":"UInt16(one)"},{"type":"text","text":" 을 호출하여 "},{"type":"codeVoice","code":"one"},{"text":" 의 값을 새로운 ","type":"text"},{"code":"UInt16","type":"codeVoice"},{"type":"text","text":" 으로 초기화하면 기존 값 대신에 새로운 값을 사용합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let twoThousand: UInt16 = 2_000","let one: UInt8 = 1","let twoThousandAndOne = twoThousand + UInt16(one)"]},{"inlineContent":[{"type":"text","text":"양쪽의 타입이 "},{"type":"codeVoice","code":"UInt16"},{"type":"text","text":" 이므로 덧셈은 이제 제대로 동작합니다. 출력 상수 ("},{"code":"twoThousandAndOne","type":"codeVoice"},{"text":")은 두 ","type":"text"},{"type":"codeVoice","code":"UInt16"},{"type":"text","text":" 값을 더하므로 "},{"code":"UInt16","type":"codeVoice"},{"type":"text","text":" 타입으로 추론됩니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"code":"SomeType (ofInitialValue)","type":"codeVoice"},{"text":" 는 Swift 타입의 초기화를 호출하고 초기화 값을 전달하는 기본적인 방법입니다. 이전에 ","type":"text"},{"type":"codeVoice","code":"UInt16"},{"text":" 은 ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" 값을 허용하는 초기화가 있으므로 초기화는 기존 "},{"type":"codeVoice","code":"UInt8"},{"text":" 에서 새 ","type":"text"},{"code":"UInt16","type":"codeVoice"},{"type":"text","text":" 을 만드는데 사용됩니다. 그러나 "},{"code":"UInt16","type":"codeVoice"},{"type":"text","text":" 이 제공하는 초기화 타입 이외에는 전달할 수 없습니다. 기존 타입을 확장하여 새로운 타입 (자신이 정의한 새로운 타입)을 받아들이는 초기화를 제공하는 것은 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions","isActive":true},{"text":" 에서 다룹니다.","type":"text"}]},{"type":"heading","text":"정수와 부동 소수점 변환 (Integer and Floating-Point Conversion)","anchor":"정수와-부동-소수점-변환-Integer-and-Floating-Point-Conversion","level":3},{"inlineContent":[{"text":"정수와 부동 소수점 숫자 타입의 변환은 명시적으로 변환해야 합니다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let three = 3","let pointOneFourOneFiveNine = 0.14159","let pi = Double(three) + pointOneFourOneFiveNine","\/\/ pi equals 3.14159, and is inferred to be of type Double"]},{"inlineContent":[{"text":"여기서 상수 ","type":"text"},{"type":"codeVoice","code":"three"},{"text":" 는 타입 ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" 의 새로운 값으로 생성하는데 사용되어 덧셈의 양쪽이 동일한 타입입니다. 이 변환이 없으면 덧셈이 허용되지 않습니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"부동 소수점을 정수로 변환하는 것 또한 명시적으로 변환해야 합니다. 정수 타입은 "},{"code":"Double","type":"codeVoice"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Float"},{"text":" 로 초기화 될 수 있습니다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let integerPi = Int(pi)","\/\/ integerPi equals 3, and is inferred to be of type Int"]},{"inlineContent":[{"text":"부동 소수점 값은 새로운 정수 값으로 초기화할 때 소수점 아래를 버림합니다. 이것은 ","type":"text"},{"type":"codeVoice","code":"4.75"},{"text":" 는 ","type":"text"},{"type":"codeVoice","code":"4"},{"type":"text","text":", 그리고 "},{"type":"codeVoice","code":"-3.9"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"-3"},{"type":"text","text":" 이 된다는 의미입니다."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":"\n"},{"type":"text","text":"숫자 상수와 변수를 결합하는 규칙은 숫자 리터럴 규칙과 다릅니다. 리터럴 값 "},{"type":"codeVoice","code":"3"},{"type":"text","text":" 은 숫자 리터럴에 명시적인 타입이 없으므로 리터럴 값 "},{"code":"0.14159","type":"codeVoice"},{"type":"text","text":" 에 직접 추가할 수 있습니다. 이것의 타입은 컴파일러가 실행되는 시점에서만 추론됩니다."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"type":"heading","text":"타입 별칭 (Type Aliases)","level":2,"anchor":"타입-별칭-Type-Aliases"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 별칭 (Type aliases)"}]},{"type":"text","text":" 은 이미 존재하는 타입을 다른 이름으로 정의합니다. 타입 별칭은 "},{"type":"codeVoice","code":"typealias"},{"text":" 키워드를 사용하여 정의할 수 있습니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"타입 별칭은 외부 소스에서 특정 크기의 데이터로 작업할 때와 같이 상황에 맞는 이름으로 기존 타입을 참조하려는 경우에 유용합니다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["typealias AudioSample = UInt16"]},{"inlineContent":[{"type":"text","text":"타입 별칭을 정의하면 원래 이름을 사용할 수 있는 모든 위치에서 별칭을 사용할 수 있습니다:"}],"type":"paragraph"},{"type":"codeListing","code":["var maxAmplitudeFound = AudioSample.min","\/\/ maxAmplitudeFound is now 0"],"syntax":"swift"},{"inlineContent":[{"text":"여기서 ","type":"text"},{"code":"AudioSample","type":"codeVoice"},{"type":"text","text":" 은 "},{"code":"UInt16","type":"codeVoice"},{"type":"text","text":" 의 별칭으로 정의됩니다. 별칭이므로 "},{"type":"codeVoice","code":"AudioSample.min"},{"type":"text","text":" 에 대한 호출은 실제로 "},{"type":"codeVoice","code":"UInt16.min"},{"type":"text","text":" 을 호출하며 "},{"type":"codeVoice","code":"maxAmplitudeFound"},{"type":"text","text":" 변수의 초기값은 "},{"code":"0","type":"codeVoice"},{"text":" 입니다.","type":"text"}],"type":"paragraph"},{"anchor":"부울-Booleans","level":2,"type":"heading","text":"부울 (Booleans)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 "},{"code":"Bool","type":"codeVoice"},{"text":" 이라 불리는 기본 ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"부울 (Boolean) 타입"}]},{"type":"text","text":" 이 있습니다. 부울 값은 오직 참 또는 거짓 값만 가지므로 _논리적 (logical)_으로 참조됩니다. Swift는 2개의 부울 상수 값인 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 와 "},{"code":"false","type":"codeVoice"},{"text":" 를 제공합니다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let orangesAreOrange = true","let turnipsAreDelicious = false"]},{"inlineContent":[{"code":"orangesAreOrange","type":"codeVoice"},{"type":"text","text":" 와 "},{"code":"turnipsAreDelicious","type":"codeVoice"},{"type":"text","text":" 의 타입은 부울 리터럴 값으로 초기화 되어 "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" 로 유추되었습니다. 위의 "},{"type":"codeVoice","code":"Int"},{"text":" 와 ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" 에서와 같이 상수 또는 변수를 초기화 시 ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"false"},{"text":" 로 선언하면 상수 또는 변수를 ","type":"text"},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" 타입으로 선언할 필요가 없습니다. 타입 추론은 Swift 코드가 이미 알고 있는 타입의 다른 값으로 상수 또는 변수를 초기화 시에 더 간결하고 읽기 쉽습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"부울 값은 ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문과 같은 조건문으로 동작할 때 특히 유용합니다:"}]},{"syntax":"swift","type":"codeListing","code":["if turnipsAreDelicious {","    print(\"Mmm, tasty turnips!\")","} else {","    print(\"Eww, turnips are horrible.\")","}","\/\/ Prints \"Eww, turnips are horrible.\""]},{"type":"paragraph","inlineContent":[{"code":"if","type":"codeVoice"},{"text":" 구문 같은 조건문은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow","type":"reference","isActive":true},{"type":"text","text":" 에서 자세히 다룹니다."}]},{"type":"paragraph","inlineContent":[{"text":"Swift의 타입 세이프티는 부울이 아닌 값이 ","type":"text"},{"type":"codeVoice","code":"Bool"},{"text":" 로 대체되는 것을 방지합니다. 아래 예제는 컴파일 시 에러를 발생합니다:","type":"text"}]},{"code":["let i = 1","if i {","    \/\/ this example will not compile, and will report an error","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"그러나 아래와 같은 예제는 정상 동작합니다:"}]},{"type":"codeListing","code":["let i = 1","if i == 1 {","    \/\/ this example will compile successfully","}"],"syntax":"swift"},{"inlineContent":[{"code":"i == 1","type":"codeVoice"},{"type":"text","text":" 비교 결과는 "},{"type":"codeVoice","code":"Bool"},{"text":" 타입이므로 이 두번째 예제는 타입 검사를 정상적으로 수행할 수 있습니다. ","type":"text"},{"code":"i == 1","type":"codeVoice"},{"type":"text","text":" 과 같은 비교는 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/BasicOperators","isActive":true,"type":"reference"},{"text":" 에서 설명합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Swift의 타입 세이프티에 대한 다른 예제와 마찬가지로 이 방법은 실수로 인한 오류를 피하고 코드의 특정 섹션의 의도를 항상 명확하도록 보장합니다.","type":"text"}]},{"text":"튜플 (Tuples)","level":2,"type":"heading","anchor":"튜플-Tuples"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"튜플 (Tuples)"}],"type":"emphasis"},{"text":" 은 여러값을 단일 복합 값으로 그룹화 합니다. 튜플안에 값은 어떠한 타입도 가능하며 서로 같은 타입일 필요는 없습니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"이 예제에서 ","type":"text"},{"type":"codeVoice","code":"(404, \"Not Found\")"},{"type":"text","text":" 는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"HTTP 상태 코드 (HTTP status code)"}]},{"text":" 를 나타내는 튜플입니다. HTTP 상태 코드는 웹 페이지를 요청할 때마다 웹 서버가 반환하는 특정 값입니다. ","type":"text"},{"type":"codeVoice","code":"404 Not Found"},{"type":"text","text":" 상태 코드는 요청한 웹 페이지가 존재하지 않을 때 반환됩니다."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let http404Error = (404, \"Not Found\")","\/\/ http404Error is of type (Int, String), and equals (404, \"Not Found\")"]},{"type":"paragraph","inlineContent":[{"code":"(404, \"Not Found\")","type":"codeVoice"},{"type":"text","text":" 튜플은 HTTP 상태 코드에 2개의 개별 값인 숫자와 사람이 읽을 수 있는 설명을 제공하는 "},{"type":"codeVoice","code":"Int"},{"text":" 와 ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" 을 함께 그룹화하여 제공합니다. 이것은 “튜플의 타입은 ","type":"text"},{"type":"codeVoice","code":"(Int, String)"},{"type":"text","text":"” 이라고 설명할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"text":"모든 타입의 튜플을 만들 수 있으며 원하는 만큼 다른 타입을 포함할 수 있습니다. 튜플의 타입 ","type":"text"},{"code":"(Int, Int, Int)","type":"codeVoice"},{"text":" 또는 ","type":"text"},{"code":"(String, Bool)","type":"codeVoice"},{"text":" 또는 실제로 필요한 다른 어떠한 것도 만들 수 있습니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"튜플의 내용을 별도의 상수 또는 변수로 "},{"inlineContent":[{"type":"text","text":"분해 (decompose)"}],"type":"emphasis"},{"text":" 하여 평소와 같이 접근할 수 있습니다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let (statusCode, statusMessage) = http404Error","print(\"The status code is \\(statusCode)\")","\/\/ Prints \"The status code is 404\"","print(\"The status message is \\(statusMessage)\")","\/\/ Prints \"The status message is Not Found\""]},{"inlineContent":[{"text":"튜플의 값 중 일부만 필요한 경우 튜플을 분해할 때 밑줄 (","type":"text"},{"code":"_","type":"codeVoice"},{"type":"text","text":")로 튜플의 일부를 무시할 수 있습니다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let (justTheStatusCode, _) = http404Error","print(\"The status code is \\(justTheStatusCode)\")","\/\/ Prints \"The status code is 404\""]},{"type":"paragraph","inlineContent":[{"text":"또는 0에서 시작하는 인덱스를 사용하여 튜플의 개별 요소 값에 접근할 수 있습니다:","type":"text"}]},{"code":["print(\"The status code is \\(http404Error.0)\")","\/\/ Prints \"The status code is 404\"","print(\"The status message is \\(http404Error.1)\")","\/\/ Prints \"The status message is Not Found\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"튜플을 정의할 때 튜플의 요소에 이름을 정할 수 있습니다:"}],"type":"paragraph"},{"code":["let http200Status = (statusCode: 200, description: \"OK\")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"튜플 요소에 이름이 있다면 요소의 값에 요소 이름으로 접근이 가능합니다:"}],"type":"paragraph"},{"code":["print(\"The status code is \\(http200Status.statusCode)\")","\/\/ Prints \"The status code is 200\"","print(\"The status message is \\(http200Status.description)\")","\/\/ Prints \"The status message is OK\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"튜플은 함수의 반환 값으로 특히 유용합니다. 웹 페이지를 검색하는 함수는 페이지 검색의 성공 또는 실패를 설명하기위해 ","type":"text"},{"type":"codeVoice","code":"(Int, String)"},{"text":" 튜플 타입을 반환할 수 있습니다. 이 함수는 각각 다른 타입의 2가지 고유한 값으로 튜플을 반환함으로써 단일 타입의 단일 값만 반환할 수 있는 경우보다 유용합니다. 자세한 내용은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","type":"reference","isActive":true},{"type":"text","text":" 를 참조 바랍니다."}],"type":"paragraph"},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":"\n"},{"text":"튜플은 관련된 값의 간단한 그룹에 유용합니다. 복잡한 데이터 구조를 생성하는데는 맞지 않습니다. 데이터 구조가 복잡한 경우 튜플이 아닌 클래스 (class) 또는 구조체 (structure)를 사용하십시오. 자세한 내용은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ClassesAndStructures","type":"reference","isActive":true},{"text":" 를 참조 바랍니다.","type":"text"}]}],"name":"Note","type":"aside"},{"text":"옵셔널 (Optionals)","anchor":"옵셔널-Optionals","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"값이 없는 경우에 "},{"type":"emphasis","inlineContent":[{"text":"옵셔널 (optionals)","type":"text"}]},{"type":"text","text":" 을 사용합니다. 옵셔널은 2가지 가능성이 있습니다: 지정된 타입의 값이 있고 옵셔널을 풀어서 값에 접근하거나 값이 없을 수도 있습니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"누락될 수 있는 값의 예로 Swift의 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 타입은 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값을 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값으로 변환하는 초기화가 존재합니다. 그러나 일부 문자열만 정수로 변환할 수 있습니다. 문자열 "},{"code":"\"123\"","type":"codeVoice"},{"text":" 은 숫자값 ","type":"text"},{"type":"codeVoice","code":"123"},{"type":"text","text":" 으로 변환될 수 있지만 문자열 "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" 는 변환할 숫자값이 없습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 을 "},{"type":"codeVoice","code":"Int"},{"text":" 로 초기화하는 것을 보여줍니다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let possibleNumber = \"123\"","let convertedNumber = Int(possibleNumber)","\/\/ The type of convertedNumber is \"optional Int\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 코드에서 초기화가 실패할 수 있으므로 "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 가 아닌 "},{"inlineContent":[{"text":"옵셔널","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 를 반환합니다."},{"text":" ","type":"text"},{"type":"text","text":"옵셔널 타입을 작성하려면 옵셔널을 포함하는 타입의 이름 다음에 물음표 ("},{"code":"?","type":"codeVoice"},{"text":") 를 작성합니다 —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"예를 들어, 옵셔널 "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 의 타입은 "},{"type":"codeVoice","code":"Int?"},{"text":" 입니다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"옵셔널 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 는 항상 어떠한 "},{"type":"codeVoice","code":"Int"},{"text":" 값 또는 값이 없음을 포함합니다.","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값과 같은 다른 타입을 포함할 수 없습니다."}]},{"level":3,"type":"heading","anchor":"nil","text":"nil"},{"type":"paragraph","inlineContent":[{"text":"옵셔널 변수에 특수한 값 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" 로 지정하여 값이 없는 상태를 나타낼 수 있습니다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var serverResponseCode: Int? = 404","\/\/ serverResponseCode contains an actual Int value of 404","serverResponseCode = nil","\/\/ serverResponseCode now contains no value"]},{"type":"paragraph","inlineContent":[{"text":"기본값이 없이 옵셔널 변수를 정의하면 이 변수는 자동적으로 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" 로 설정됩니다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var surveyAnswer: String?","\/\/ surveyAnswer is automatically set to nil"]},{"inlineContent":[{"code":"if","type":"codeVoice"},{"text":" 구문은 옵셔널과 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 을 비교하여 옵셔널에 값이 포함되어 있는지 확인할 수 있습니다. “같음” 연산자 ("},{"code":"==","type":"codeVoice"},{"text":") 또는 “같지 않음” 연산자 (","type":"text"},{"type":"codeVoice","code":"!="},{"text":")로 비교를 수행할 수 있습니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"옵셔널에 값이 있다면 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 과 “같지 않음”으로 간주됩니다:"}],"type":"paragraph"},{"type":"codeListing","code":["let possibleNumber = \"123\"","let convertedNumber = Int(possibleNumber)","","if convertedNumber != nil {","    print(\"convertedNumber contains some integer value.\")","}","\/\/ Prints \"convertedNumber contains some integer value.\""],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"옵셔널이 아닌 상수 또는 변수에는 "},{"type":"codeVoice","code":"nil"},{"text":" 을 사용할 수 없습니다.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"코드에서 상수 또는 변수가 특정 조건에서 값이 없이 동작하려면 적절한 타입의 옵셔널 값을 선언해야합니다."},{"type":"text","text":" "},{"type":"text","text":"옵셔널이 아닌 값으로 선언된 상수 또는 변수는 "},{"type":"codeVoice","code":"nil"},{"text":" 값이 포함되지 않도록 보장됩니다.","type":"text"},{"text":" ","type":"text"},{"text":"옵셔널이 아닌 값에 ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 을 할당하면 컴파일 오류가 발생합니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널과 옵셔널이 아닌 값의 분리는 누락된 정보를 명시적으로 표시할 수 있고 없는 값을 처리하는 코드를 더 쉽게 작성할 수 있습니다."},{"text":" ","type":"text"},{"type":"text","text":"이런 실수는 컴파일 때 오류가 발생하므로 옵셔널을 옵셔널이 아닌 것처럼 처리할 수 없습니다."},{"text":" ","type":"text"},{"type":"text","text":"값을 언래핑한 후에는 "},{"type":"codeVoice","code":"nil"},{"text":" 에 대한 값을 검사할 필요가 없으므로 코드의 다른 부분에서 이 값을 동일하게 확인할 필요가 없습니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 값에 접근할 때 코드에서 "},{"code":"nil","type":"codeVoice"},{"text":" 과 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" 이 아닌 것에 대해 모두 처리해야 합니다.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"다음 섹션에서 설명하듯이 값이 없을 때 수행할 수 있는 작업이 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"값이 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 일 때 해당값에 대한 동작을 건너뜁니다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"nil","type":"codeVoice"},{"text":" 을 반환하거나 ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/OptionalChaining","isActive":true},{"text":" 에서","type":"text"},{"type":"text","text":" "},{"text":"설명한 ","type":"text"},{"type":"codeVoice","code":"?."},{"type":"text","text":" 연산자를 사용해서 "},{"type":"codeVoice","code":"nil"},{"text":" 값을 전파합니다.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"??"},{"type":"text","text":" 연산자를 사용해서 대체값을 제공합니다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"!","type":"codeVoice"},{"text":" 연산자를 사용해서 프로그램을 멈춥니다.","type":"text"}],"type":"paragraph"}]}]},{"type":"aside","style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":""},{"text":" ","type":"text"},{"type":"text","text":"Objective-C 에서 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 은 객체가 존재하지 않는 포인터입니다."},{"text":" ","type":"text"},{"text":"Swift 에서 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" 은 포인터가 아닙니다 — 특정 타입의 값이 없다는 의미입니다.","type":"text"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"모든"}]},{"type":"text","text":" 타입의 옵셔널은 객체 타입 뿐만 아니라 "},{"type":"codeVoice","code":"nil"},{"text":" 로 설정할 수 있습니다.","type":"text"}],"type":"paragraph"}]},{"text":"옵셔널 바인딩 (Optional Binding)","level":3,"anchor":"옵셔널-바인딩-Optional-Binding","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 바인딩 (optional binding) 은 옵셔널이 값을 포함하고 있는지 확인하고 값이 있는 경우 해당 값을 임시 상수 또는 변수로 사용할 수 있게 해줍니다. 옵셔널 바인딩은 "},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"while"},{"text":" 구문에서 옵셔널에 값이 있는지 체크하고 단일 동작의 일부로 상수 또는 변수로 추출할 수 있습니다. ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 와 "},{"code":"while","type":"codeVoice"},{"text":" 구문은 ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow","type":"reference"},{"type":"text","text":" 에서 자세히 다룹니다."}]},{"type":"paragraph","inlineContent":[{"code":"if","type":"codeVoice"},{"type":"text","text":" 구문에서 옵셔널 바인딩은 아래와 같이 사용합니다:"}]},{"code":["if let <#constantName#> = <#someOptional#> {","   <#statements#>","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"강제 언래핑 (forced unwrapping) 보다 옵셔널 바인딩을 사용하여 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals"},{"text":" 섹선에 있는 예제의 ","type":"text"},{"code":"possibleNumber","type":"codeVoice"},{"type":"text","text":" 를 다시 작성할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["if let actualNumber = Int(possibleNumber) {","    print(\"The string \\\"\\(possibleNumber)\\\" has an integer value of \\(actualNumber)\")","} else {","    print(\"The string \\\"\\(possibleNumber)\\\" could not be converted to an integer\")","}","\/\/ Prints \"The string \"123\" has an integer value of 123\""]},{"inlineContent":[{"type":"text","text":"이 코드는 아래와 같이 읽을 수 있습니다:"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"“"},{"code":"Int(possibleNumber)","type":"codeVoice"},{"text":" 에 의해 반환된 옵셔널 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 에 값이 포함되어 있으면 ","type":"text"},{"code":"actualNumber","type":"codeVoice"},{"type":"text","text":" 라는 새로운 상수에 옵셔널에 포함된 값을 설정합니다.”"}]},{"inlineContent":[{"type":"text","text":"변환에 성공하면 "},{"code":"actualNumber","type":"codeVoice"},{"type":"text","text":" 상수는 "},{"code":"if","type":"codeVoice"},{"type":"text","text":" 구문에 첫번째 중괄호 내에서 사용할 수 있습니다."},{"text":" ","type":"text"},{"type":"text","text":"옵셔널에서 포함된 값으로 초기화되었고 적절한 옵셔널이 아닌 타입입니다."},{"type":"text","text":" "},{"text":"이런 경우에 ","type":"text"},{"type":"codeVoice","code":"possibleNumber"},{"text":" 의 타입은 ","type":"text"},{"type":"codeVoice","code":"Int?"},{"text":" 이므로 ","type":"text"},{"code":"actualNumber","type":"codeVoice"},{"text":" 의 타입은 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 입니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"값에 접근한 후에 기존 옵셔널 상수 또는 변수를 참조할 필요가 없다면 같은 이름으로 새로운 상수 또는 변수를 사용할 수 있습니다:"}],"type":"paragraph"},{"syntax":"swift","code":["let myNumber = Int(possibleNumber)","\/\/ Here, myNumber is an optional integer","if let myNumber = myNumber {","    \/\/ Here, myNumber is a non-optional integer","    print(\"My number is \\(myNumber)\")","}","\/\/ Prints \"My number is 123\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 코드는 이전 예제에서의 코드와 마찬가지로 "},{"type":"codeVoice","code":"myNumber"},{"type":"text","text":" 가 값이 있는지 없는지를 먼저 확인합니다. "},{"type":"codeVoice","code":"myNumber"},{"type":"text","text":" 가 값이 있다면 해당 값이 새로운 "},{"code":"myNumber","type":"codeVoice"},{"text":" 라는 상수에 설정됩니다. ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문 안에서 "},{"code":"myNumber","type":"codeVoice"},{"text":" 는 새로운 옵셔널이 아닌 상수를 참조합니다.","type":"text"},{"type":"text","text":" "},{"text":"Writing ","type":"text"},{"type":"codeVoice","code":"myNumber"},{"type":"text","text":" before or after the "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"refers to the original optional integer constant."},{"text":" ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" 구문의 앞에 또는 뒤에 ","type":"text"},{"code":"myNumber","type":"codeVoice"},{"text":" 를 작성하면 원래 옵셔널 정수 상수를 참조합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"이러한 코드는 일반적이기 때문에 옵셔널 값을 언래핑 하는데 더 짧게 사용할 수 있습니다: 언래핑할 상수 또는 변수의 이름만 작성합니다. 언래핑된 새로운 상수 또는 변수는 암시적으로 같은 이름의 옵셔널 값을 사용합니다.","type":"text"}]},{"code":["if let myNumber {","    print(\"My number is \\(myNumber)\")","}","\/\/ Prints \"My number is 123\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"옵셔널 바인딩은 상수와 변수 둘다 사용이 가능합니다. "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문에 첫번째 중괄호에서 "},{"type":"codeVoice","code":"myNumber"},{"text":" 의 값을 변경하고 싶다면 ","type":"text"},{"type":"codeVoice","code":"if var myNumber"},{"text":" 로 대신 쓸 수 있으며 옵셔널에 포함된 값은 상수가 아닌 변수로 사용할 수 있습니다. ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" 구문내에서 ","type":"text"},{"type":"codeVoice","code":"myNumber"},{"text":" 를 바꾸면 이것은 지역 변수에만 적용되며, 기존 언래핑된 옵셔널 상수 또는 변수에 적용되지 ","type":"text"},{"inlineContent":[{"type":"text","text":"않습니다"}],"type":"emphasis"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"필요한 경우 "},{"type":"codeVoice","code":"if"},{"text":" 구문에 쉼표로 구분하여 옵셔널 바인딩 및 부울 조건을 여러개 포함할 수 있습니다. 옵셔널 바인딩 값 중 하나가 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" 이거나 부울 조건이 ","type":"text"},{"type":"codeVoice","code":"false"},{"text":" 로 판단되면 전체 ","type":"text"},{"type":"codeVoice","code":"if"},{"text":" 구문의 조건은 ","type":"text"},{"code":"false","type":"codeVoice"},{"text":" 로 간주됩니다. 다음의 예는 같은 ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" 구문입니다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["if let firstNumber = Int(\"4\"), let secondNumber = Int(\"42\"), firstNumber < secondNumber && secondNumber < 100 {","    print(\"\\(firstNumber) < \\(secondNumber) < 100\")","}","\/\/ Prints \"4 < 42 < 100\"","","if let firstNumber = Int(\"4\") {","    if let secondNumber = Int(\"42\") {","        if firstNumber < secondNumber && secondNumber < 100 {","            print(\"\\(firstNumber) < \\(secondNumber) < 100\")","        }","    }","}","\/\/ Prints \"4 < 42 < 100\""],"syntax":"swift"},{"inlineContent":[{"code":"if","type":"codeVoice"},{"type":"text","text":" 구문에서 옵셔널 바인딩으로 생성된 상수와 변수는 "},{"code":"if","type":"codeVoice"},{"text":" 구문의 본문내에서만 사용 가능합니다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"반대로 "},{"type":"codeVoice","code":"guard"},{"text":" 구문에서 생성된 상수와 변수는 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow#%EC%9D%B4%EB%A5%B8-%EC%A2%85%EB%A3%8C-Early-Exit","isActive":true,"type":"reference"},{"type":"text","text":" 에서 설명되어 있듯이"},{"text":" ","type":"text"},{"type":"codeVoice","code":"guard"},{"text":" 구문 다음에 코드에서 사용 가능합니다.","type":"text"}],"type":"paragraph"},{"text":"대체값 제공 (Providing a Fallback Value)","anchor":"대체값-제공-Providing-a-Fallback-Value","type":"heading","level":3},{"inlineContent":[{"text":"누락된 값을 처리하는 다른 방법은","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"nil-결합 연산자 ("},{"code":"??","type":"codeVoice"},{"text":") 사용하여 기본값을 제공하는 방법입니다.","type":"text"},{"type":"text","text":" "},{"text":"옵셔널에서 ","type":"text"},{"code":"??","type":"codeVoice"},{"type":"text","text":" 의 왼편이 "},{"code":"nil","type":"codeVoice"},{"text":" 이 아니면,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"값은 언래핑되고 사용됩니다."},{"type":"text","text":" "},{"type":"text","text":"그렇지 않으면 "},{"type":"codeVoice","code":"??"},{"text":" 의 오른편에 값이 사용됩니다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"예를 들어,"},{"type":"text","text":" "},{"text":"아래 코드는 이름이 지정되면 지정된 이름에 인사하고","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"이름이 "},{"type":"codeVoice","code":"nil"},{"text":" 이면 일반적인 인사를 사용합니다.","type":"text"}],"type":"paragraph"},{"code":["let name: String? = nil","let greeting = \"Hello, \" + (name ?? \"friend\") + \"!\"","print(greeting)","\/\/ Prints \"Hello, friend!\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"대체값 제공에 대해 "},{"code":"??","type":"codeVoice"},{"type":"text","text":" 사용에 대한 더 자세한 내용은 "},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/BasicOperators#Nil-%EA%B2%B0%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90-Nil-Coalescing-Operator","type":"reference"},{"text":" 를 참고 바랍니다.","type":"text"}]},{"level":3,"text":"강제 언래핑 (Force Unwrapping)","type":"heading","anchor":"강제-언래핑-Force-Unwrapping"},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로그래머의 에러 또는 원치않는 상태와 같은 실패를 "},{"type":"codeVoice","code":"nil"},{"text":" 로 표현하려면","type":"text"},{"type":"text","text":" "},{"type":"text","text":"옵셔널의 이름 뒤에 느낌표 ("},{"type":"codeVoice","code":"!"},{"text":") 를 추가하여 접근할 수 있습니다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"이것을 옵셔널의 값의 "},{"type":"emphasis","inlineContent":[{"text":"강제 언래핑 (force unwrapping)","type":"text"}]},{"type":"text","text":" 이라고 합니다."},{"type":"text","text":" "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 이 아닌 값에 강제 언래핑을 하면,"},{"text":" ","type":"text"},{"type":"text","text":"언래핑된 값을 결과로 얻습니다."},{"text":" ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 값을 강제 언래핑하면 런타임 에러가 발생합니다."}]},{"inlineContent":[{"type":"codeVoice","code":"!"},{"type":"text","text":" 은 "},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/fatalerror(_:file:line:)","type":"reference"},{"type":"text","text":" 의"},{"text":" ","type":"text"},{"type":"text","text":"짧은 작성법 입니다."},{"type":"text","text":" "},{"text":"예를 들어, 아래 코드는 동일한 접근을 보여줍니다:","type":"text"}],"type":"paragraph"},{"code":["let possibleNumber = \"123\"","let convertedNumber = Int(possibleNumber)","","let number = convertedNumber!","","guard let number = convertedNumber else {","    fatalError(\"The number was invalid\")","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"위 코드의 두 버전은 값을 항상 가지는 ","type":"text"},{"type":"codeVoice","code":"convertedNumber"},{"text":" 에 의존하는 것을 보여줍니다.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"위의 접근방식 중 하나를 사용해서 코드의 일부로 작성하면 런타임 시 요구사항이 참인지 확인할 수 있습니다."}]},{"inlineContent":[{"type":"text","text":"데이터 요구사항 적용과 런타임 시 가정 확인에 대한 자세한 내용은 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%97%AD%EC%84%A4%EA%B3%BC-%EC%A0%84%EC%A0%9C%EC%A1%B0%EA%B1%B4-Assertions-and-Preconditions"},{"type":"text","text":" 을 참고 바랍니다."}],"type":"paragraph"},{"anchor":"암시적으로-언래핑된-옵셔널-Implicitly-Unwrapped-Optionals","text":"암시적으로 언래핑된 옵셔널 (Implicitly Unwrapped Optionals)","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"위에서 설명했듯이 옵셔널은 상수 또는 변수가 “값이 없음”을 허락하고 알려줍니다. 옵셔널은 값이 존재하는지 "},{"code":"if","type":"codeVoice"},{"type":"text","text":" 구문에서 체크할 수 있고 값이 존재한다면 옵셔널 값에 접근하기위해 옵셔널 바인딩을 이용할 수 있습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"때로는 프로그램 구조에서 옵셔널이 값을 처음 설정한 후에는 항상 값을 갖는 것은 분명합니다. 이러한 경우 "},{"inlineContent":[{"type":"text","text":"항상"}],"type":"emphasis"},{"type":"text","text":" 값이 있다고 가정할 수 있으므로 접근할 때마다 옵셔널의 값을 확인하고 언래핑 할 필요가 없습니다."}]},{"inlineContent":[{"type":"text","text":"이러한 옵셔널은 _암시적으로 언래핑 된 옵셔널 (implicitly unwrapped optionals)_로 정의됩니다. 옵셔널을 만들기위해 타입뒤에 물음표 ("},{"code":"String?","type":"codeVoice"},{"type":"text","text":")를 작성하는 대신에 느낌표 ("},{"code":"String!","type":"codeVoice"},{"type":"text","text":") 로 암시적으로 언래핑 된 옵셔널을 작성합니다. 사용할 때 옵셔널 이름의 뒤에 느낌표를 위치시키는 것보다 선언할 때 옵셔널 타입 뒤에 느낌표를 위치시키는 것이 더 좋습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑 된 옵셔널은 옵셔널이 처음 정의된 직후에 옵셔널의 값이 존재하는 것으로 확인되고 그 이후 모든 시점에 존재한다고 가정할 수 있는 경우에 유용합니다. Swift에서 암시적으로 언래핑 된 옵셔널은 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/AutomaticReferenceCounting#%EB%AF%B8%EC%86%8C%EC%9C%A0-%EC%B0%B8%EC%A1%B0%EC%99%80-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-Unowned-References-and-Implicitly-Unwrapped-Optional-Properties","isActive":true},{"text":" 에서 설명한 대로 클래스 초기화 중에 주로 사용합니다.","type":"text"}]},{"inlineContent":[{"text":"나중에 변수가 ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" 이 될 가능성이 있다면 암시적으로 언래핑된 옵셔널을 사용하면 안됩니다.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"변수를 사용하는 동안 "},{"code":"nil","type":"codeVoice"},{"text":" 값을 확인해야 한다면 일반적인 옵셔널 타입을 사용해야 합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑 된 옵셔널은 내부적으로 옵셔널이지만 옵셔널에 접근할 때마다 옵셔널 값을 풀 필요없이 옵셔널이 아닌 값처럼 사용할 수도 있습니다. 다음 예제는 명시적 "},{"type":"codeVoice","code":"String"},{"text":" 로서 랩핑된 값에 접근할 때 옵셔널 문자열과 암시적으로 언래핑 된 옵셔널 문자열의 동작 차이를 보여줍니다:","type":"text"}]},{"code":["let possibleString: String? = \"An optional string.\"","let forcedString: String = possibleString! \/\/ Requires explicit unwrapping","","let assumedString: String! = \"An implicitly unwrapped optional string.\"","let implicitString: String = assumedString \/\/ Unwrapped automatically"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"필요한 경우 암시적으로 언래핑 된 옵셔널은 옵셔널을 강제로 언래핑을 허락하는 것으로 생각할 수 있습니다. 암시적으로 언래핑 된 옵셔널을 사용할 때 Swift는 처음에 기존의 옵셔널 값으로 사용하려고 하고 사용이 불가능할 경우 Swift는 값을 강제로 언래핑 합니다. 위의 코드에서 옵셔널 값 ","type":"text"},{"type":"codeVoice","code":"assumedString"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"implicitString"},{"type":"text","text":" 이 명시적으로 옵셔널이 아닌 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 타입이기 때문에 "},{"type":"codeVoice","code":"implicitString"},{"type":"text","text":" 에 값을 할당하기 전에 강제로 언래핑 됩니다. 아래의 코드에서 "},{"code":"optionalString","type":"codeVoice"},{"type":"text","text":" 은 명시적 타입이 없으므로 기본적으로 옵셔널입니다."}]},{"type":"codeListing","code":["let optionalString = assumedString","\/\/ The type of optionalString is \"String?\" and assumedString isn't force-unwrapped."],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"암시적으로 언래핑 된 옵셔널이 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 이고 래핑된 값에 접근하려고 하면 런타임 에러가 발생합니다."},{"type":"text","text":" "},{"type":"text","text":"결과는 값을 포함하지 않는 일반적인 옵셔널을 강제 언래핑을 하기위해 느낌표를 작성한 것과 같습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑 된 옵셔널은 일반 옵셔널과 같은 방법으로 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 체크를 할 수 있습니다:"}]},{"syntax":"swift","type":"codeListing","code":["if assumedString != nil {","    print(assumedString!)","}","\/\/ Prints \"An implicitly unwrapped optional string.\""]},{"inlineContent":[{"type":"text","text":"옵셔널 바인딩과 함께 암시적으로 언래핑 된 옵셔널은 단일 구문으로 해당 값을 확인하고 언래핑할 수 있습니다."}],"type":"paragraph"},{"type":"codeListing","code":["if let definiteString = assumedString {","    print(definiteString)","}","\/\/ Prints \"An implicitly unwrapped optional string.\""],"syntax":"swift"},{"text":"에러 처리 (Error Handling)","anchor":"에러-처리-Error-Handling","type":"heading","level":2},{"inlineContent":[{"text":"프로그램이 실행되는 동안 에러가 발생할 때 처리하기위해 _에러 처리 (error handling)_를 사용합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"값의 존재 유무를 사용하여 함수의 성공 또는 실패를 전달할 수 있는 옵셔널과 달리 에러 처리를 사용하면 에러 원인을 판별하고 필요한 경우 에러를 프로그램의 다른 부분으로 전파 할 수 있습니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"함수에 에러 조건이 되면 에러가 _발생_합니다. 해당 함수의 호출자는 에러를 _포착_하고 적절하게 응답할 수 있습니다.","type":"text"}]},{"code":["func canThrowAnError() throws {","    \/\/ this function may or may not throw an error","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수는 선언에 "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" 키워드를 포함시켜 에러가 발생할 수 있음을 나타냅니다. 에러를 발생할 수 있는 함수를 호출할 때는 표현식 앞에 "},{"type":"codeVoice","code":"try"},{"text":" 키워드를 붙여야 합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Swift는 ","type":"text"},{"type":"codeVoice","code":"catch"},{"text":" 절에 의해 처리될 때까지 현재 범위에서 에러를 자동으로 전파합니다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["do {","    try canThrowAnError()","    \/\/ no error was thrown","} catch {","    \/\/ an error was thrown","}"]},{"inlineContent":[{"code":"do","type":"codeVoice"},{"type":"text","text":" 구문은 에러를 하나 이상의 "},{"type":"codeVoice","code":"catch"},{"text":" 절로 전파할 수 있는 새로운 범위를 만듭니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"다음은 에러 처리를 사용하여 다양한 에러 조건에 응답하는 방법의 예입니다:"}]},{"type":"codeListing","syntax":"swift","code":["func makeASandwich() throws {","    \/\/ ...","}","","do {","    try makeASandwich()","    eatASandwich()","} catch SandwichError.outOfCleanDishes {","    washDishes()","} catch SandwichError.missingIngredients(let ingredients) {","    buyGroceries(ingredients)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예에서 "},{"type":"codeVoice","code":"makeASandwich()"},{"text":" 함수는 깨끗한 그릇을 사용할 수 없거나 재료가 없는 경우 에러가 발생할 것입니다. ","type":"text"},{"code":"makeASandwich()","type":"codeVoice"},{"text":" 함수는 에러를 발생할 수 있으므로 ","type":"text"},{"type":"codeVoice","code":"try"},{"text":" 표현식으로 래핑됩니다. 함수 호출을 ","type":"text"},{"code":"do","type":"codeVoice"},{"type":"text","text":" 구문으로 래핑하면 어떠한 에러도 "},{"code":"catch","type":"codeVoice"},{"type":"text","text":" 절로 전파됩니다."}]},{"inlineContent":[{"text":"에러가 발생하지 않으면 ","type":"text"},{"code":"eatASandwich()","type":"codeVoice"},{"type":"text","text":" 함수가 호출됩니다. "},{"code":"SandwichError.outOfCleanDishes","type":"codeVoice"},{"text":" 에러가 발생하면 ","type":"text"},{"type":"codeVoice","code":"washDishes()"},{"text":" 함수가 호출됩니다. ","type":"text"},{"code":"SandwichError.missingIngredients","type":"codeVoice"},{"text":" 에러가 발생하면 ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" 패턴에 의해 캡쳐된 ","type":"text"},{"type":"codeVoice","code":"[String]"},{"type":"text","text":" 값과 함께 "},{"code":"buyGroceries(_:)","type":"codeVoice"},{"type":"text","text":" 함수가 호출됩니다."}],"type":"paragraph"},{"inlineContent":[{"text":"에러 발생, 포착, 전파는 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ErrorHandling","isActive":true,"type":"reference"},{"text":" 에서 자세히 다룹니다.","type":"text"}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"역설과-전제조건-Assertions-and-Preconditions","text":"역설과 전제조건 (Assertions and Preconditions)"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"역설과 전제조건 (Assertions and preconditions)"}],"type":"emphasis"},{"text":" 은 런타임시 발생하는 조건입니다. 추가 코드를 실행하기 전에 이를 사용하여 필수조건이 충족되는지 확인할 수 있습니다. 역설 또는 전제조건의 부울 조건이 ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":" 이면 코드는 평소와 같이 진행됩니다. 조건이 "},{"code":"false","type":"codeVoice"},{"type":"text","text":" 로 판단되면 프로그램의 현재 상태는 유효하지 않아 코드 실행은 종료되고 앱은 종료됩니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"역설과 전제조건은 가정과 기대치를 표현하므로 코드의 일부로 포함할 수 있습니다. 역설은 개발과정에서 실수와 잘못된 가정을 찾는데 도움이 되고 전제조건은 프로덕션 문제를 감지하는데 도움이 됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"런타임 시 기대치를 확인하는 것 이외에 역설과 전제조건은 또한 코드 내에서 유용한 문서 형식이 됩니다. 위의 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC-Error-Handling","isActive":true},{"text":" 와 다르게 역설과 전제조건은 복구 가능하거나 예상되는 에러에 사용되지 않습니다. 실패한 역설 또는 전제조건은 유효하지 않은 프로그램 상태를 나타내기 때문에 실패한 상태를 잡을 방법은 없습니다.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"유효하지 않은 상태에서 복구하는 것은 불가능합니다."},{"text":" ","type":"text"},{"type":"text","text":"역설이 실패하면 프로그램의 데이터 중 하나가 유효하지 않다는 의미입니다 —"},{"text":" ","type":"text"},{"text":"그러나 그것이 왜 유효하지 않은지 추가로 다른 상태도 유효하지 않은지 알 수 없습니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"역설과 전제조건을 사용하는 것은 유효하지 않는 조건이 발생하지 않게 코드를 디자인하기 위함입니다. 그러나 유효한 데이터 및 상태를 적용하기 위해 이를 사용하면 유효하지 않은 상태가 발생하면 앱이 종료되기 때문에 더 쉽게 문제에 대해 디버깅 할 수 있습니다."},{"text":" ","type":"text"},{"text":"가정을 확인하지 않으면,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"다른 코드가 실패하기 시작하고,"},{"text":" ","type":"text"},{"type":"text","text":"사용자 데이터가 손상된 후에야"},{"type":"text","text":" "},{"text":"이런 종류의 문제를 알 수 있습니다.","type":"text"},{"text":" ","type":"text"},{"text":"유효하지 않은 상태가 감지되는 즉시 실행을 중지하면 해당 유효하지 않은 상태로 인한 피해를 제한하는데 도움이 됩니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"역설과 전제조건의 차이점은 언제 체크되는지에 있습니다: 역설은 오직 디버그 빌드에서 체크되지만 전제조건은 디버그와 프로덕션 빌드에서 체크됩니다. 프로덕션 빌드일 때 역설 내부의 조건은 실행되지 않습니다. 이 의미는 프로덕션에서 성능의 영향이 없이 개발 단계에서 많은 양의 역설을 사용할 수 있다는 뜻입니다."}]},{"type":"heading","text":"역설을 통한 디버깅 (Debugging with Assertions)","level":3,"anchor":"역설을-통한-디버깅-Debugging-with-Assertions"},{"type":"paragraph","inlineContent":[{"text":"Swift 표준 라이브러리에 ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1541112-assert","type":"reference","isActive":true},{"text":" 함수로 역설을 작성할 수 있습니다. 이 함수에 ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 로 판단될 표현식과 조건이 "},{"code":"false","type":"codeVoice"},{"type":"text","text":" 일 경우 출력될 메세지를 전달합니다. 예를 들어:"}]},{"code":["let age = -3","assert(age >= 0, \"A person's age can't be less than zero.\")","\/\/ This assertion fails because -3 is not >= 0."],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예에서 코드는 "},{"type":"codeVoice","code":"age"},{"type":"text","text":" 가 음수가 아니고 "},{"code":"age >= 0","type":"codeVoice"},{"type":"text","text":" 이 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 일 경우 이어서 실행됩니다. "},{"type":"codeVoice","code":"age"},{"text":" 가 음수이면 ","type":"text"},{"type":"codeVoice","code":"age >= 0"},{"text":" 은 ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":" 가 되고 역설은 실패되고 애플리케이션은 종료됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"예를 들어 평범하게 조건만 반복될 때 메세지를 생략할 수 있습니다."}]},{"syntax":"swift","type":"codeListing","code":["assert(age >= 0)"]},{"type":"paragraph","inlineContent":[{"text":"코드가 이미 조건이 체크되었다면 역설이 실패되었는지를 알 수 있는 ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1539616-assertionfailure"},{"text":" 함수를 사용합니다. 예를 들어:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if age > 10 {","    print(\"You can ride the roller-coaster or the ferris wheel.\")","} else if age >= 0 {","    print(\"You can ride the ferris wheel.\")","} else {","    assertionFailure(\"A person's age can't be less than zero.\")","}"]},{"text":"강제 전제조건 (Enforcing Preconditions)","anchor":"강제-전제조건-Enforcing-Preconditions","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"조건이 거짓 일 가능성이 있을 때마다 전제조건을 사용하지만 코드가 순차적으로 실행되려면 "},{"inlineContent":[{"text":"확실하게","type":"text"}],"type":"emphasis"},{"text":" 참이어야 합니다. 예를 들어 어떤 값들이 범위를 벗어나는지 또는 함수에 유효한 값이 전달되는지 체크하기위해 전제조건을 사용합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1540960-precondition","isActive":true},{"text":" 함수로 전제조건을 작성할 수 있습니다. 이 함수에 ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" 또는 ","type":"text"},{"code":"false","type":"codeVoice"},{"text":" 로 판단될 표현식과 조건이 ","type":"text"},{"type":"codeVoice","code":"false"},{"type":"text","text":" 일 경우 출력될 메세지를 전달합니다. 예를 들어:"}]},{"code":["\/\/ In the implementation of a subscript...","precondition(index > 0, \"Index must be greater than zero.\")"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1539374-preconditionfailure","isActive":true,"type":"reference"},{"type":"text","text":" 함수를 호출하여 실패가 발생했음을 알릴 수 있습니다. 예를 들어 유효한 데이터는 스위치의 기본 케이스가 아닌 다른 케이스에서 처리되어야 합니다."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Note","type":"text"},{"type":"text","text":"\n"},{"text":"체크하지 않는 모드 (","type":"text"},{"code":"-Ounchecked","type":"codeVoice"},{"text":")로 컴파일하면 전제조건은 체크하지 않습니다. 컴파일러는 전제조건은 항상 참이라고 가정하고 코드에 알맞게 최적화 합니다. 그러나 ","type":"text"},{"type":"codeVoice","code":"fatalError(_:file:line:)"},{"type":"text","text":" 함수는 최적화 설정과 무관하게 항상 중지를 실행합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토타입과 초기 개발단계에서 아직 구현되지 않은 기능에서 "},{"type":"codeVoice","code":"fatalError(_:file:line:)"},{"text":" 을 사용할 수 있으며 ","type":"text"},{"code":"fatalError(\"Unimplemented\")","type":"codeVoice"},{"text":" 와 같이 작성할 수 있습니다. 역설 또는 전제조건과 다르게 치명적인 에러는 절대 최적화 되지 않기 때문에 이 구현을 만나면 항상 중지됩니다.","type":"text"}]}],"name":"Note"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/TSPLK"]]},"kind":"article","abstract":[{"text":"일반적인 종류의 데이터로 동작하고 기본 구문을 작성합니다.","type":"text"}],"metadata":{"title":"기본 (The Basics)"},"identifier":{"url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics","interfaceLanguage":"swift"},"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values":{"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","type":"topic","title":"여러개의 반환값이 있는 함수 (Functions with Multiple Return Values)","url":"\/documentation\/the-swift-programming-language-korean\/functions#%25EC%2597%25AC%25EB%259F%25AC%25EA%25B0%259C%25EC%259D%2598-%25EB%25B0%2598%25ED%2599%2598%25EA%25B0%2592%25EC%259D%25B4-%25EC%259E%2588%25EB%258A%2594-%25ED%2595%25A8%25EC%2588%2598-Functions-with-Multiple-Return-Values","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%EC%83%81%EC%88%98-%EC%84%A0%EC%96%B8-Constant-Declaration":{"abstract":[],"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EC%83%81%EC%88%98-%EC%84%A0%EC%96%B8-Constant-Declaration","title":"상수 선언 (Constant Declaration)","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25EC%2583%2581%25EC%2588%2598-%25EC%2584%25A0%25EC%2596%25B8-Constant-Declaration"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/OptionalChaining":{"title":"옵셔널 체이닝 (Optional Chaining)","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/OptionalChaining","role":"article","url":"\/documentation\/the-swift-programming-language-korean\/optionalchaining","abstract":[{"type":"text","text":"언래핑 없이 옵셔널 값의 멤버에 접근합니다."}],"kind":"article","type":"topic"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EA%B8%B0%EB%B3%B8%EA%B0%92-Default-Parameter-Values":{"kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/functions#%25ED%258C%258C%25EB%259D%25BC%25EB%25AF%25B8%25ED%2584%25B0-%25EA%25B8%25B0%25EB%25B3%25B8%25EA%25B0%2592-Default-Parameter-Values","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EA%B8%B0%EB%B3%B8%EA%B0%92-Default-Parameter-Values","title":"파라미터 기본값 (Default Parameter Values)","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/AutomaticReferenceCounting#%EB%AF%B8%EC%86%8C%EC%9C%A0-%EC%B0%B8%EC%A1%B0%EC%99%80-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-Unowned-References-and-Implicitly-Unwrapped-Optional-Properties":{"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/AutomaticReferenceCounting#%EB%AF%B8%EC%86%8C%EC%9C%A0-%EC%B0%B8%EC%A1%B0%EC%99%80-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-Unowned-References-and-Implicitly-Unwrapped-Optional-Properties","type":"topic","title":"미소유 참조와 암묵적 언래핑된 옵셔널 프로퍼티 (Unowned References and Implicitly Unwrapped Optional Properties)","url":"\/documentation\/the-swift-programming-language-korean\/automaticreferencecounting#%25EB%25AF%25B8%25EC%2586%258C%25EC%259C%25A0-%25EC%25B0%25B8%25EC%25A1%25B0%25EC%2599%2580-%25EC%2595%2594%25EB%25AC%25B5%25EC%25A0%2581-%25EC%2596%25B8%25EB%259E%2598%25ED%2595%2591%25EB%2590%259C-%25EC%2598%25B5%25EC%2585%2594%25EB%2584%2590-%25ED%2594%2584%25EB%25A1%259C%25ED%258D%25BC%25ED%258B%25B0-Unowned-References-and-Implicitly-Unwrapped-Optional-Properties","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/BasicOperators":{"type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/basicoperators","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/BasicOperators","kind":"article","role":"article","abstract":[{"type":"text","text":"할당, 산술, 그리고 비교와 같은 동작을 수행합니다."}],"title":"기본 연산자 (Basic Operators)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%ED%83%80%EC%9E%85-%EC%84%B8%EC%9D%B4%ED%94%84%ED%8B%B0%EC%99%80-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0-Type-Safety-and-Type-Inference":{"abstract":[],"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%ED%83%80%EC%9E%85-%EC%84%B8%EC%9D%B4%ED%94%84%ED%8B%B0%EC%99%80-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0-Type-Safety-and-Type-Inference","title":"타입 세이프티와 타입 추론 (Type Safety and Type Inference)","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25ED%2583%2580%25EC%259E%2585-%25EC%2584%25B8%25EC%259D%25B4%25ED%2594%2584%25ED%258B%25B0%25EC%2599%2580-%25ED%2583%2580%25EC%259E%2585-%25EC%25B6%2594%25EB%25A1%25A0-Type-Safety-and-Type-Inference"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes":{"type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes","kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes","role":"article","abstract":[{"type":"text","text":"배열, 집합, 그리고 딕셔너리를 사용하여 데이터를 구성합니다."}],"title":"콜렉션 타입 (Collection Types)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals":{"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals","type":"topic","title":"옵셔널 (Optionals)","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25EC%2598%25B5%25EC%2585%2594%25EB%2584%2590-Optionals","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ControlFlow#%EC%9D%B4%EB%A5%B8-%EC%A2%85%EB%A3%8C-Early-Exit":{"abstract":[],"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow#%EC%9D%B4%EB%A5%B8-%EC%A2%85%EB%A3%8C-Early-Exit","title":"이른 종료 (Early Exit)","url":"\/documentation\/the-swift-programming-language-korean\/controlflow#%25EC%259D%25B4%25EB%25A5%25B8-%25EC%25A2%2585%25EB%25A3%258C-Early-Exit"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ClassesAndStructures":{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ClassesAndStructures","kind":"article","role":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/classesandstructures","abstract":[{"type":"text","text":"데이터를 캡슐화하는 사용자 정의 타입을 모델링합니다."}],"title":"구조체와 클래스 (Structures and Classes)"},"https://developer.apple.com/documentation/swift/1539616-assertionfailure":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1539616-assertionfailure","titleInlineContent":[{"type":"codeVoice","code":"assertionFailure(_:file:line:)"}],"type":"link","title":"assertionFailure(_:file:line:)","url":"https:\/\/developer.apple.com\/documentation\/swift\/1539616-assertionfailure"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Extensions":{"kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions","abstract":[{"text":"기존 타입에 기능을 추가합니다.","type":"text"}],"type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/extensions","title":"확장 (Extensions)","role":"article"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ControlFlow":{"type":"topic","title":"제어 흐름 (Control Flow)","abstract":[{"type":"text","text":"분기, 루프, 이른 종료로 코드를 구성합니다."}],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow","kind":"article","url":"\/documentation\/the-swift-programming-language-korean\/controlflow","role":"article"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/StringsAndCharacters#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%82%BD%EC%9E%85-String-Interpolation":{"abstract":[],"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/StringsAndCharacters#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%82%BD%EC%9E%85-String-Interpolation","title":"문자열 삽입 (String Interpolation)","url":"\/documentation\/the-swift-programming-language-korean\/stringsandcharacters#%25EB%25AC%25B8%25EC%259E%2590%25EC%2597%25B4-%25EC%2582%25BD%25EC%259E%2585-String-Interpolation"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC-Error-Handling":{"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC-Error-Handling","type":"topic","title":"에러 처리 (Error Handling)","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25EC%2597%2590%25EB%259F%25AC-%25EC%25B2%2598%25EB%25A6%25AC-Error-Handling","abstract":[]},"https://developer.apple.com/documentation/swift/1541112-assert":{"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1541112-assert","titleInlineContent":[{"type":"codeVoice","code":"assert(_:_:file:line:)"}],"title":"assert(_:_:file:line:)","url":"https:\/\/developer.apple.com\/documentation\/swift\/1541112-assert"},"https://developer.apple.com/documentation/swift/1540960-precondition":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1540960-precondition","titleInlineContent":[{"type":"codeVoice","code":"precondition(_:_:file:line:)"}],"type":"link","title":"precondition(_:_:file:line:)","url":"https:\/\/developer.apple.com\/documentation\/swift\/1540960-precondition"},"https://developer.apple.com/documentation/swift/1539374-preconditionfailure":{"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/1539374-preconditionfailure","titleInlineContent":[{"type":"codeVoice","code":"preconditionFailure(_:file:line:)"}],"title":"preconditionFailure(_:file:line:)","url":"https:\/\/developer.apple.com\/documentation\/swift\/1539374-preconditionfailure"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%97%AD%EC%84%A4%EA%B3%BC-%EC%A0%84%EC%A0%9C%EC%A1%B0%EA%B1%B4-Assertions-and-Preconditions":{"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%97%AD%EC%84%A4%EA%B3%BC-%EC%A0%84%EC%A0%9C%EC%A1%B0%EA%B1%B4-Assertions-and-Preconditions","type":"topic","title":"역설과 전제조건 (Assertions and Preconditions)","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25EC%2597%25AD%25EC%2584%25A4%25EA%25B3%25BC-%25EC%25A0%2584%25EC%25A0%259C%25EC%25A1%25B0%25EA%25B1%25B4-Assertions-and-Preconditions","abstract":[]},"https://developer.apple.com/documentation/swift/fatalerror(_:file:line:)":{"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/fatalerror(_:file:line:)","titleInlineContent":[{"type":"codeVoice","code":"fatalError(_:file:line:)"}],"title":"fatalError(_:file:line:)","url":"https:\/\/developer.apple.com\/documentation\/swift\/fatalerror(_:file:line:)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/BasicOperators#Nil-%EA%B2%B0%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90-Nil-Coalescing-Operator":{"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/BasicOperators#Nil-%EA%B2%B0%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90-Nil-Coalescing-Operator","type":"topic","title":"Nil-결합 연산자 (Nil-Coalescing Operator)","url":"\/documentation\/the-swift-programming-language-korean\/basicoperators#Nil-%25EA%25B2%25B0%25ED%2595%25A9-%25EC%2597%25B0%25EC%2582%25B0%25EC%259E%2590-Nil-Coalescing-Operator","abstract":[]},"doc://org.swift.tsplk/documentation/TSPLK":{"abstract":[],"kind":"article","type":"topic","title":"The Swift Programming Language (한국어)","identifier":"doc:\/\/org.swift.tsplk\/documentation\/TSPLK","role":"collection","url":"\/documentation\/tsplk"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ErrorHandling":{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ErrorHandling","kind":"article","role":"article","type":"topic","abstract":[{"type":"text","text":"에러에 응답하고 복구합니다."}],"url":"\/documentation\/the-swift-programming-language-korean\/errorhandling","title":"에러 처리 (Error Handling)"}}}