{"abstract":[{"text":"값을 일치시키고 분리합니다.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/TSPLK"]]},"metadata":{"title":"패턴 (Patterns)"},"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"패턴 (pattern)","type":"text"}]},{"type":"text","text":" 은 단일 값 또는 복합 값의 구조를 나타냅니다. 예를 들어 튜플 "},{"code":"(1, 2)","type":"codeVoice"},{"type":"text","text":" 의 구조는 콤마로 구분된 두 요소의 리스트입니다. 패턴은 특정값이 아닌 값의 구조를 나타내기 때문에 다양한 값과 일치 시킬 수 있습니다. 예를 들어 패턴 "},{"type":"codeVoice","code":"(x, y)"},{"text":" 은 튜플 ","type":"text"},{"code":"(1, 2)","type":"codeVoice"},{"type":"text","text":" 와 다른 두 요소 튜플과 일치합니다. 패턴을 값과 일치시키는 것 외에도 복합 값의 일부 또는 전체를 추출하고 각 부분을 상수 또는 변수 이름으로 바인드 할 수 있습니다."}]},{"inlineContent":[{"type":"text","text":"Swift 에는 두가지의 기본 패턴이 있습니다: 모든 종류의 값과 일치하는 패턴과 런타임에 지정된 값과 일치하지 않을 수 있는 패턴이 있습니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"패턴의 첫번째 종류는 단순 변수, 상수, 그리고 옵셔널 바인딩에서 값을 구조화 하는데 사용됩니다. 와일드 카드 패턴, 식별자 패턴, 그리고 이를 포함하는 모든 값 바인딩 또는 튜플 패턴이 포함됩니다. 이러한 패턴에 타입 주석을 지정하여 특정 타입의 값만 일치되도록 제한할 수 있습니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"패턴의 두번째 종류는 전체 패턴 일치에 사용되며 일치하려는 값이 런타임 때 없을 수 있습니다. 열거형 케이스 패턴, 옵셔널 패턴, 표현식 패턴, 그리고 타입-캐스팅 패턴을 포함합니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 케이스 라벨, "},{"type":"codeVoice","code":"do"},{"type":"text","text":" 구문의 "},{"code":"catch","type":"codeVoice"},{"type":"text","text":" 절, 또는 "},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"while","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", 또는 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"text":" 구문의 케이스 조건에서 이 패턴을 사용합니다.","type":"text"}],"type":"paragraph"},{"style":"note","type":"aside","name":"Grammar of a pattern","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"wildcard-pattern","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"identifier-pattern","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"type-annotation","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"value-binding-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-pattern","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"type-annotation","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"enum-case-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"optional-pattern"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"expression-pattern"}],"type":"emphasis"}]}]},{"anchor":"와일드-카드-패턴-Wildcard-Pattern","level":2,"type":"heading","text":"와일드 카드 패턴 (Wildcard Pattern)"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"와일드 카드 패턴 (wildcard pattern)"}],"type":"emphasis"},{"text":" 은 모든 값과 일치하고 무시되며 언더바 (","type":"text"},{"type":"codeVoice","code":"_"},{"type":"text","text":") 로 구성됩니다. 일치하는 값에 대해 신경쓰지 않을 경우에 와일드 카드 패턴을 사용합니다. 예를 들어 다음의 코드는 닫긴 범위 "},{"type":"codeVoice","code":"1...3"},{"type":"text","text":" 을 반복하고 루프의 각 반복의 범위의 현재값을 무시합니다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["for _ in 1...3 {","    \/\/ Do something three times.","}"]},{"style":"note","type":"aside","name":"Grammar of a wildcard pattern","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"wildcard-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"_","type":"codeVoice"}]}]}]},{"type":"heading","text":"식별자 패턴 (Identifier Pattern)","level":2,"anchor":"식별자-패턴-Identifier-Pattern"},{"inlineContent":[{"inlineContent":[{"text":"식별자 패턴 (identifier pattern)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 은 모든 값과 일치하고 일치하는 값을 변수 또는 상수 이름으로 바인드 합니다. 예를 들어 다음의 상수 선언에서 "},{"type":"codeVoice","code":"someValue"},{"type":"text","text":" 는 타입 "},{"code":"Int","type":"codeVoice"},{"text":" 의 ","type":"text"},{"type":"codeVoice","code":"42"},{"type":"text","text":" 값이 일치하는 식별자 패턴입니다:"}],"type":"paragraph"},{"type":"codeListing","code":["let someValue = 42"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"일치가 성공하면 값 ","type":"text"},{"type":"codeVoice","code":"42"},{"type":"text","text":" 는 상수 이름 "},{"type":"codeVoice","code":"someValue"},{"text":" 에 바인드 (할당) 됩니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"변수 또는 상수 선언의 왼쪽의 패턴이 식별자 패턴일 때 식별자 패턴은 암시적으로 값-바인딩 패턴 (value-binding pattern) 의 하위 패턴입니다."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"identifier-pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"}],"type":"paragraph"}],"style":"note","type":"aside","name":"Grammar of an identifier pattern"},{"anchor":"값-바인딩-패턴-Value-Binding-Pattern","type":"heading","level":2,"text":"값-바인딩 패턴 (Value-Binding Pattern)"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"값-바인딩 패턴 (value-binding pattern)"}],"type":"emphasis"},{"type":"text","text":" 은 변수 또는 상수 이름에 일치되는 값으로 바인드 합니다. 상수의 이름에 일치되는 값을 바인드 하는 값-바인딩 패턴은 "},{"type":"codeVoice","code":"let"},{"type":"text","text":" 키워드로 시작합니다; 변수의 이름에 바인드 하면 "},{"code":"var","type":"codeVoice"},{"text":" 키워드로 시작합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"값-바인딩 패턴 내에서 식별자 패턴은 일치하는 값으로 새로운 명명된 변수 또는 상수로 바인드 됩니다. 예를 들어 튜플의 요소를 분해하고 각 요소의 값을 해당 식별자 패턴에 바인드 할 수 있습니다."}]},{"syntax":"swift","code":["let point = (3, 2)","switch point {","    \/\/ Bind x and y to the elements of point.","case let (x, y):","    print(\"The point is at (\\(x), \\(y)).\")","}","\/\/ Prints \"The point is at (3, 2).\""],"type":"codeListing"},{"inlineContent":[{"text":"위의 예제에서 ","type":"text"},{"type":"codeVoice","code":"let"},{"type":"text","text":" 은 튜플 패턴 "},{"code":"(x, y)","type":"codeVoice"},{"text":" 에서 각 식별자 패턴에 배포합니다. 이 동작으로 인해 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스 "},{"type":"codeVoice","code":"case let (x, y):"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"case (let x, let y):"},{"type":"text","text":" 은 동일합니다."}],"type":"paragraph"},{"style":"note","type":"aside","name":"Grammar of a value-binding pattern","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"value-binding-pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"code":"var","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"text":" | ","type":"text"},{"inlineContent":[{"code":"let","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]}],"type":"paragraph"}]},{"anchor":"튜플-패턴-Tuple-Pattern","type":"heading","text":"튜플 패턴 (Tuple Pattern)","level":2},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"튜플 패턴 (tuple pattern)","type":"text"}]},{"text":" 은 소괄호로 묶인 콤마로 구분된 0개 이상의 패턴의 리스트입니다. 튜플 패턴은 해당 튜플 타입의 값과 일치합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 주석을 사용하여 튜플 타입의 특정 종류와 일치하도록 하기 위해 튜플 패턴을 제한할 수 있습니다. 예를 들어 상수 선언 "},{"type":"codeVoice","code":"let (x, y): (Int, Int) = (1, 2)"},{"text":" 에서 튜플 패턴 ","type":"text"},{"type":"codeVoice","code":"(x, y): (Int, Int)"},{"text":" 은 두 요소 모두 타입 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 의 튜플 타입만 일치합니다."}]},{"type":"paragraph","inlineContent":[{"text":"튜플 패턴이 ","type":"text"},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":" 구문 또는 변수 또는 상수 선언에서 패턴으로 사용되면 와일드 카드 패턴, 식별자 패턴, 옵셔널 패턴, 또는 이를 포함하는 다른 튜플 패턴만 포함할 수 있습니다. 예를 들어 튜플 패턴 "},{"code":"(x, 0)","type":"codeVoice"},{"type":"text","text":" 에서 요소 "},{"type":"codeVoice","code":"0"},{"text":" 은 표현식 패턴이므로 다음의 코드는 유효하지 않습니다:","type":"text"}]},{"code":["let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]","\/\/ This code isn't valid.","for (x, 0) in points {","    \/* ... *\/","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"단일 요소를 포함하는 튜플 패턴 주변의 소괄호는 아무런 효과가 없습니다. 패턴은 단일 요소의 타입의 값과 일치합니다. 예를 들어 다음은 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let a = 2        \/\/ a: Int = 2","let (a) = 2      \/\/ a: Int = 2","let (a): Int = 2 \/\/ a: Int = 2"]},{"type":"aside","name":"Grammar of a tuple pattern","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"tuple-pattern-element-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element","type":"text"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"tuple-pattern-element"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"tuple-pattern-element"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"}],"type":"paragraph"}]},{"type":"heading","anchor":"열거형-케이스-패턴-Enumeration-Case-Pattern","level":2,"text":"열거형 케이스 패턴 (Enumeration Case Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"열거형 케이스 패턴 (enumeration case pattern)"}]},{"text":" 은 존재하는 열거형 타입의 케이스와 일치합니다. 열거형 케이스 패턴은 ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" 구문 케이스 라벨과 ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"while"},{"text":", ","type":"text"},{"type":"codeVoice","code":"guard"},{"type":"text","text":", 그리고 "},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" 구문의 케이스 조건에서 나타납니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"일치 시키려는 열거형 케이스에 연관된 값이 있는 경우 해당 열거형 케이스 패턴은 각 연관된 값에 대한 하나의 요소를 포함하는 튜플 패턴을 지정해야 합니다. 연관된 값을 포함하는 열거형 케이스를 일치 시키기 위해 "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" 구문을 사용하는 예제는 "},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%97%B0%EA%B4%80%EB%90%9C-%EA%B0%92-Associated-Values","type":"reference"},{"type":"text","text":" 을 참고 바랍니다."}],"type":"paragraph"},{"inlineContent":[{"text":"열거형 케이스 패턴은 옵셔널로 래핑된 케이스의 값과도 일치합니다. 이 간략한 구문으로 옵셔널 패턴을 생략할 수 있습니다. ","type":"text"},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" 은 열거형으로 구현되므로 "},{"type":"codeVoice","code":".none"},{"type":"text","text":" 과 "},{"code":".some","type":"codeVoice"},{"text":" 은 열거형 타입의 케이스로 동일한 switch 에 나타날 수 있습니다.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["enum SomeEnum { case left, right }","let x: SomeEnum? = .left","switch x {","case .left:","    print(\"Turn left\")","case .right:","    print(\"Turn right\")","case nil:","    print(\"Keep going straight\")","}","\/\/ Prints \"Turn left\""]},{"name":"Grammar of an enumeration case pattern","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"enum-case-pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enum-case-name"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"tuple-pattern","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]}],"type":"paragraph"}],"type":"aside"},{"level":2,"text":"옵셔널 패턴 (Optional Pattern)","type":"heading","anchor":"옵셔널-패턴-Optional-Pattern"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"옵셔널 패턴 (optional pattern)"}]},{"text":" 은 ","type":"text"},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 열거형의 "},{"type":"codeVoice","code":"some(Wrapped)"},{"text":" 케이스에 래핑된 값과 일치합니다. 옵셔널 패턴은 식별자 패턴과 물음표 바로 뒤에 오는 것으로 구성되며 열거형 케이스 패턴과 동일한 위치에 나타납니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 패턴은 "},{"type":"codeVoice","code":"Optional"},{"text":" 열거형 케이스 패턴에 대한 구문 설탕 이므로 다음은 동일합니다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let someOptional: Int? = 42","\/\/ Match using an enumeration case pattern.","if case .some(let x) = someOptional {","    print(x)","}","","\/\/ Match using an optional pattern.","if case let x? = someOptional {","    print(x)","}"]},{"inlineContent":[{"type":"text","text":"옵셔널 패턴은 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"text":" 구문에서 옵셔널 값의 배열을 반복하는 편리한 방법을 제공하여 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 이 아닌 요소에 대해서만 루프의 본문을 실행합니다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]","\/\/ Match only non-nil values.","for case let number? in arrayOfOptionalInts {","    print(\"Found a \\(number)\")","}","\/\/ Found a 2","\/\/ Found a 3","\/\/ Found a 5"]},{"name":"Grammar of an optional pattern","style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier-pattern","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"?","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}],"type":"aside"},{"level":2,"type":"heading","text":"타입-캐스팅 패턴 (Type-Casting Patterns)","anchor":"타입-캐스팅-패턴-Type-Casting-Patterns"},{"inlineContent":[{"type":"text","text":"타입-캐스팅 패턴 (type-casting pattern) 은 "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴과 "},{"code":"as","type":"codeVoice"},{"text":" 패턴 두가지가 있습니다. ","type":"text"},{"type":"codeVoice","code":"is"},{"text":" 패턴은 ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 케이스 라벨에서만 나타납니다. "},{"code":"is","type":"codeVoice"},{"type":"text","text":" 와 "},{"code":"as","type":"codeVoice"},{"text":" 패턴은 다음의 형식을 가집니다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["is <#type#>","<#pattern#> as <#type#>"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"is"},{"text":" 패턴은 런타임 시 해당 값의 타입이 ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴의 오른편에 지정한 타입과 일치하거나 해당 타입의 하위 클래스가 일치하면 값으로 일치됩니다. "},{"code":"is","type":"codeVoice"},{"text":" 패턴은 타입 캐스트를 동작하지만 반환된 타입을 버린다는 것에서 ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" 연산자와 유사하게 동작합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"as","type":"codeVoice"},{"text":" 패턴은 런타임 시 해당 값의 타입이 ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" 패턴의 오른편에 지정한 타입과 일치하거나 해당 타입의 하위 클래스가 일치하면 값으로 일치합니다. 일치가 성공하면 일치된 값의 타입은 "},{"code":"as","type":"codeVoice"},{"type":"text","text":" 패턴의 오른편에 지정한 "},{"inlineContent":[{"type":"text","text":"패턴 (pattern)"}],"type":"emphasis"},{"type":"text","text":" 으로 캐스팅 됩니다."}]},{"type":"paragraph","inlineContent":[{"code":"is","type":"codeVoice"},{"text":" 와 ","type":"text"},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴으로 값을 일치 시키기 위해 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 사용하는 예제는 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting#Any-%EC%99%80-AnyObject-%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85-Type-Casting-for-Any-and-AnyObject","isActive":true,"type":"reference"},{"text":" 을 참고 바랍니다.","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"is-pattern","type":"text"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"as-pattern"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"is-pattern","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"is"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"text":"as-pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"as","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]}],"style":"note","name":"Grammar of a type casting pattern","type":"aside"},{"level":2,"type":"heading","anchor":"표현식-패턴-Expression-Pattern","text":"표현식 패턴 (Expression Pattern)"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"표현식 패턴 (expression pattern)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 은 표현식의 값을 표현합니다. 표현식 패턴은 "},{"type":"codeVoice","code":"switch"},{"text":" 구문 케이스 라벨에서만 나타납니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"표현식 패턴에 의해 표현된 표현식은 Swift 표준 라이브러리 "},{"code":"~=","type":"codeVoice"},{"type":"text","text":" 연산자를 사용하여 입력 표현식의 값과 비교합니다. "},{"type":"codeVoice","code":"~="},{"type":"text","text":" 연산자가 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 를 반환하면 일치는 성공합니다. 기본적으로 "},{"code":"~=","type":"codeVoice"},{"text":" 연산자는 ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" 연산자를 사용하여 동일한 타입의 두 값을 비교합니다. 다음 예제에서 보듯이 범위내에 값이 포함되는지 검사하기 위해 값의 범위로 값을 일치시킬 수도 있습니다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let point = (1, 2)","switch point {","case (0, 0):","    print(\"(0, 0) is at the origin.\")","case (-2...2, -2...2):","    print(\"(\\(point.0), \\(point.1)) is near the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"(1, 2) is near the origin.\""],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"사용자 정의 표현식 일치 동작을 제공하기 위해 "},{"code":"~=","type":"codeVoice"},{"type":"text","text":" 연산자를 오버로드 할 수 있습니다. 예를 들어 포인트의 문자열 표현으로 "},{"code":"point","type":"codeVoice"},{"type":"text","text":" 표현식을 비교하기 위해 위의 예제를 다시 작성할 수 있습니다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Overload the ~= operator to match a string with an integer.","func ~= (pattern: String, value: Int) -> Bool {","    return pattern == \"\\(value)\"","}","switch point {","case (\"0\", \"0\"):","    print(\"(0, 0) is at the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"The point is at (1, 2).\""]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"expression-pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]}]}],"style":"note","name":"Grammar of an expression pattern","type":"aside"}],"kind":"content"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"sections":[],"kind":"article","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Patterns"},"references":{"doc://org.swift.tsplk/documentation/TSPLK":{"url":"\/documentation\/tsplk","role":"collection","abstract":[],"kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/TSPLK","type":"topic","title":"The Swift Programming Language (한국어)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Enumerations#%EC%97%B0%EA%B4%80%EB%90%9C-%EA%B0%92-Associated-Values":{"title":"연관된 값 (Associated Values)","url":"\/documentation\/the-swift-programming-language-korean\/enumerations#%25EC%2597%25B0%25EA%25B4%2580%25EB%2590%259C-%25EA%25B0%2592-Associated-Values","kind":"section","type":"topic","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%97%B0%EA%B4%80%EB%90%9C-%EA%B0%92-Associated-Values"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TypeCasting#Any-%EC%99%80-AnyObject-%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85-Type-Casting-for-Any-and-AnyObject":{"type":"topic","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting#Any-%EC%99%80-AnyObject-%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85-Type-Casting-for-Any-and-AnyObject","url":"\/documentation\/the-swift-programming-language-korean\/typecasting#Any-%25EC%2599%2580-AnyObject-%25EC%2597%2590-%25EB%258C%2580%25ED%2595%259C-%25ED%2583%2580%25EC%259E%2585-%25EC%25BA%2590%25EC%258A%25A4%25ED%258C%2585-Type-Casting-for-Any-and-AnyObject","kind":"section","title":"Any 와 AnyObject 에 대한 타입 캐스팅 (Type Casting for Any and AnyObject)"}}}