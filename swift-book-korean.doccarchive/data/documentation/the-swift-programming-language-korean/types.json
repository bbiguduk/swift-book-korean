{"kind":"article","schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"text":"내장된 타입과 복합 타입을 사용합니다.","type":"text"}],"metadata":{"title":"타입 (Types)"},"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/TSPLK"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Types"},"primaryContentSections":[{"content":[{"inlineContent":[{"type":"text","text":"Swift 에서 명명된 타입과 복합 타입의 두가지 종류가 있습니다. "},{"inlineContent":[{"type":"text","text":"명명된 타입 (named type)"}],"type":"emphasis"},{"text":" 은 정의될 때 특정 이름을 부여할 수 있는 타입입니다. 명명된 타입은 클래스, 구조체, 열거형, 그리고 프로토콜을 포함합니다. 예를 들어 ","type":"text"},{"code":"MyClass","type":"codeVoice"},{"text":" 라는 사용자 정의 클래스의 인스턴스는 ","type":"text"},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":" 타입을 가집니다. 사용자 정의 명명된 타입 외에도 Swift 표준 라이브러리는 배열, 딕셔너리, 그리고 옵셔널 값을 나타내는 타입을 포함하여 일반적으로 사용되는 명명된 타입을 정의합니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"데이터 타입 (Data types) 은 다른 언어에서 일반적으로 기본 또는 원시라고 간주됩니다 — 숫자, 문자, 그리고 문자열을 나타내는 타입 — Swift 표준 라이브러리에서는 구조체를 사용하여 정의되고 구현된 타입입니다. 명명된 타입이므로 필요에 따라 프로그램에 맞게 적절하게 동작을 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions"},{"type":"text","text":" 과 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration","isActive":true},{"type":"text","text":" 에서 설명된대로 확장 선언을 사용하여 확장할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"복합 타입 (compound type)"}]},{"text":" 은 Swift 언어 자체에 정의된 이름이 없는 타입입니다. 복합 타입은 함수 타입과 튜플 타입 두가지가 있습니다. 복합 타입은 명명된 타입과 다른 복합 타입을 포함할 수 있습니다. 예를 들어 튜플 타입 ","type":"text"},{"code":"(Int, (Int, Int))","type":"codeVoice"},{"text":" 는 첫번째는 명명된 타입인 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":", 두번째는 다른 복합 타입 "},{"code":"(Int, Int)","type":"codeVoice"},{"type":"text","text":" 인 두개의 요소가 포함됩니다."}]},{"inlineContent":[{"type":"text","text":"명명된 타입 또는 복합 타입을 묶을 소괄호를 넣을 수 있습니다. 그러나 타입을 묶은 소괄호는 아무런 영향을 주지 않습니다. 예를 들어 "},{"code":"(Int)","type":"codeVoice"},{"text":" 는 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 와 같습니다."}],"type":"paragraph"},{"inlineContent":[{"text":"이 챕터에서는 Swift 언어 자체에 정의된 타입과 Swift 의 타입 추론에 대해 설명합니다.","type":"text"}],"type":"paragraph"},{"name":"Grammar of a type","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"function-type","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"array-type","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-type"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"optional-type","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"implicitly-unwrapped-optional-type","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-type"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"opaque-type","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"boxed-protocol-type","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"metatype-type","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"any-type"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-type"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]}]}],"type":"aside"},{"level":2,"type":"heading","anchor":"%ED%83%80%EC%9E%85-%EC%A3%BC%EC%84%9D-Type-Annotation","text":"타입 주석 (Type Annotation)"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"타입 주석 (type annotation)","type":"text"}]},{"type":"text","text":" 은 변수 또는 표현식의 타입을 명시적으로 지정합니다. 타입 주석은 아래 예제에서 보여주듯이 콜론 ("},{"code":":","type":"codeVoice"},{"type":"text","text":") 으로 시작하고 타입으로 끝납니다:"}],"type":"paragraph"},{"code":["let someTuple: (Double, Double) = (3.14159, 2.71828)","func someFunction(a: Int) { \/* ... *\/ }"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"첫번째 예제에서 표현식 "},{"code":"someTuple","type":"codeVoice"},{"type":"text","text":" 은 튜플 타입 "},{"type":"codeVoice","code":"(Double, Double)"},{"type":"text","text":" 을 갖도록 지정됩니다. 두번째 예제는 함수 "},{"type":"codeVoice","code":"someFunction"},{"text":" 에 파라미터 ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" 는 타입 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 갖도록 지정합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 주석은 타입 앞에 타입 속성의 옵셔널 리스트을 포함할 수 있습니다."}]},{"name":"Grammar of a type annotation","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"attributes","type":"text"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]}],"type":"aside","style":"note"},{"level":2,"anchor":"%ED%83%80%EC%9E%85-%EC%8B%9D%EB%B3%84%EC%9E%90-Type-Identifier","type":"heading","text":"타입 식별자 (Type Identifier)"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 식별자 (type identifier)"}]},{"text":" 는 명명된 타입 또는 명명된 타입 또는 복합 타입의 타입 별칭 (type alias) 을 나타냅니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"대부분의 경우 타입 식별자는 식별자로 같은 이름의 명명된 타입을 직접 참조합니다. 예를 들어 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 는 명명된 타입 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 를 직접 참조하는 타입 식별자이고 타입 식별자 "},{"code":"Dictionary<String, Int>","type":"codeVoice"},{"type":"text","text":" 는 명명된 타입 "},{"code":"Dictionary<String, Int>","type":"codeVoice"},{"type":"text","text":" 를 직접 참조합니다."}]},{"type":"paragraph","inlineContent":[{"text":"타입 식별자가 동일한 이름의 타입을 참조하지 않는 두가지 경우가 있습니다. 첫번째는 타입 식별자는 명명된 타입 또는 복합 타입의 타입 별칭을 나타냅니다. 예를 들어 아래 예제에서 타입 주석에서 ","type":"text"},{"code":"Point","type":"codeVoice"},{"text":" 의 사용은 튜플 타입 ","type":"text"},{"code":"(Int, Int)","type":"codeVoice"},{"text":" 를 나타냅니다.","type":"text"}]},{"code":["typealias Point = (Int, Int)","let origin: Point = (0, 0)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"두번째 경우 타입 식별자는 다른 모듈에서 선언되거나 다른 타입 내에 중첩된 명명된 타입을 참조하기 위해 점 (","type":"text"},{"code":".","type":"codeVoice"},{"text":") 구문을 사용합니다. 예를 들어 다음 코드의 타입 식별자는 ","type":"text"},{"code":"ExampleModule","type":"codeVoice"},{"type":"text","text":" 모듈에 선언된 명명된 타입 "},{"type":"codeVoice","code":"MyType"},{"type":"text","text":" 을 참조합니다."}]},{"code":["var someValue: ExampleModule.MyType"],"syntax":"swift","type":"codeListing"},{"name":"Grammar of a type identifier","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"type-identifier"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-name"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"generic-argument-clause"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" | "},{"inlineContent":[{"text":"type-name","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"generic-argument-clause","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type-identifier","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"text":"type-name","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"}]}],"type":"aside","style":"note"},{"anchor":"%ED%8A%9C%ED%94%8C-%ED%83%80%EC%9E%85-Tuple-Type","level":2,"text":"튜플 타입 (Tuple Type)","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"튜플 타입 (tuple type)"}]},{"text":" 은 소괄호로 묶인 콤마로 구분된 타입의 리스트입니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"튜플 타입을 함수의 반환 타입으로 사용하여 함수가 여러값을 포함하는 단일 튜플을 반환하도록 할 수 있습니다. 튜플 타입의 요소에 이름을 지정하고 해당 이름을 사용하여 개별 요소의 값을 참조할 수도 있습니다. 요소 이름은 바로 뒤에 콜론 (","type":"text"},{"type":"codeVoice","code":":"},{"type":"text","text":") 이 오는 식별자로 구성됩니다. 이러한 기능을 보여주는 예제는 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","isActive":true,"type":"reference"},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"튜플 타입의 요소가 이름을 가지는 경우 이름은 타입의 부분입니다."}]},{"syntax":"swift","type":"codeListing","code":["var someTuple = (top: 10, bottom: 12)  \/\/ someTuple is of type (top: Int, bottom: Int)","someTuple = (top: 4, bottom: 42) \/\/ OK: names match","someTuple = (9, 99)              \/\/ OK: names are inferred","someTuple = (left: 5, right: 5)  \/\/ Error: names don't match"]},{"inlineContent":[{"text":"모든 튜플 타입은 빈 튜플 타입 인 ","type":"text"},{"type":"codeVoice","code":"()"},{"type":"text","text":" 에 대한 타입 별칭인 "},{"code":"Void","type":"codeVoice"},{"text":" 를 제외하고 두 개 이상의 타입을 포함합니다.","type":"text"}],"type":"paragraph"},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"tuple-type"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"text":"tuple-type-element","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"tuple-type-element-list","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-type-element-list","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"tuple-type-element"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element-list"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"element-name"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"text":" | ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"element-name"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"}],"type":"paragraph"}],"name":"Grammar of a tuple type"},{"text":"함수 타입 (Function Type)","type":"heading","anchor":"%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85-Function-Type","level":2},{"inlineContent":[{"text":"함수 타입 (function type) 은 함수, 메서드, 또는 클로저의 타입을 나타내고 화살표 (","type":"text"},{"type":"codeVoice","code":"->"},{"type":"text","text":") 로 구분된 파라미터와 반환 타입으로 구성됩니다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["(<#parameter type#>) -> <#return type#>"]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"파라미터 타입 (parameter type)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 은 콤마로 구분된 타입의 리스트입니다. "},{"type":"emphasis","inlineContent":[{"type":"text","text":"반환 타입 (return type)"}]},{"type":"text","text":" 은 튜플 타입일 수 있기 때문에 함수 타입은 여러값을 반환하는 함수와 메서드를 지원합니다."}]},{"inlineContent":[{"text":"함수 타입 ","type":"text"},{"code":"() -> T","type":"codeVoice"},{"type":"text","text":" (여기서 "},{"code":"T","type":"codeVoice"},{"type":"text","text":" 는 모든 타입) 의 파라미터는 "},{"code":"autoclosure","type":"codeVoice"},{"text":" 속성을 적용하여 호출 부분에서 암시적으로 클로저를 생성할 수 있습니다. 이것은 함수를 호출할 때 명시적으로 클로저를 작성할 필요없이 표현식의 평가를 연기하는 구문상 편리함을 제공합니다. 자동 클로저 함수 타입 파라미터의 예제는 ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures","type":"reference"},{"type":"text","text":" 를 참고 바랍니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"함수 타입은 ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"파라미터 타입","type":"text"}]},{"type":"text","text":" 에 가변 파라미터 (variadic parameters) 를 가질 수 있습니다. 구문적으로 가변 파라미터는 "},{"type":"codeVoice","code":"Int..."},{"text":" 와 같이 기본 타입 이름과 바로 뒤에 점 3개 (","type":"text"},{"code":"...","type":"codeVoice"},{"text":") 로 구성됩니다. 가변 파라미터는 기본 타입 이름의 요소를 포함하는 배열로 처리됩니다. 예를 들어 가변 파라미터 ","type":"text"},{"type":"codeVoice","code":"Int..."},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"[Int]"},{"type":"text","text":" 로 처리됩니다. 가변 파라미터를 사용하는 예제는 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters"},{"type":"text","text":" 를 참고 바랍니다."}]},{"inlineContent":[{"type":"text","text":"in-out 파라미터 (in-out parameter) 를 지정하려면 "},{"type":"codeVoice","code":"inout"},{"type":"text","text":" 키워드를 파라미터 타입 앞에 붙여야 합니다. "},{"code":"inout","type":"codeVoice"},{"type":"text","text":" 키워드로 가변 파라미터나 반환 타입으로 표시할 수 없습니다. In-out 파라미터는 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters","isActive":true},{"text":" 에 설명되어 있습니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입에 파라미터가 하나만 가지고 있고 파라미터 타입이 튜플 타입인 경우 함수 타입을 작성할 때 튜플 타입을 괄호로 묶어야 합니다. 예를 들어 "},{"type":"codeVoice","code":"((Int, Int)) -> Void"},{"type":"text","text":" 는 튜플 타입 "},{"code":"(Int, Int)","type":"codeVoice"},{"type":"text","text":" 의 단일 파라미터를 가지고 값을 반환하지 않는 함수 타입입니다. 반대로 괄호가 없으면 "},{"code":"(Int, Int) -> Void","type":"codeVoice"},{"text":" 는 두 개의 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 파라미터를 가지고 값을 반환하지 않는 함수 타입입니다. 마찬가지로 ","type":"text"},{"type":"codeVoice","code":"Void"},{"text":" 는 ","type":"text"},{"type":"codeVoice","code":"()"},{"text":" 에 대한 타입 별칭 이므로 함수 타입 ","type":"text"},{"code":"(Void) -> Void","type":"codeVoice"},{"type":"text","text":" 는 "},{"code":"(()) -> ()","type":"codeVoice"},{"text":" 와 같습니다—빈 튜플인 단일 인수를 가지는 함수와 같습니다. 이 타입은 ","type":"text"},{"type":"codeVoice","code":"() -> ()"},{"text":" 와 같지 않습니다 — 인수를 가지지 않는 함수입니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"함수와 메서드에 인수 이름은 해당 함수 타입의 일부가 아닙니다. 예를 들어:","type":"text"}]},{"syntax":"swift","code":["func someFunction(left: Int, right: Int) {}","func anotherFunction(left: Int, right: Int) {}","func functionWithDifferentLabels(top: Int, bottom: Int) {}","","var f = someFunction \/\/ The type of f is (Int, Int) -> Void, not (left: Int, right: Int) -> Void.","f = anotherFunction              \/\/ OK","f = functionWithDifferentLabels  \/\/ OK","","func functionWithDifferentArgumentTypes(left: Int, right: String) {}","f = functionWithDifferentArgumentTypes     \/\/ Error","","func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}","f = functionWithDifferentNumberOfArguments \/\/ Error"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"인수 라벨은 함수 타입의 일부분이 아니므로 함수 타입을 작성할 때 생략합니다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var operation: (lhs: Int, rhs: Int) -> Int     \/\/ Error","var operation: (_ lhs: Int, _ rhs: Int) -> Int \/\/ OK","var operation: (Int, Int) -> Int               \/\/ OK"]},{"type":"paragraph","inlineContent":[{"text":"함수 타입에 하나 이상의 화살표 (","type":"text"},{"code":"->","type":"codeVoice"},{"type":"text","text":") 를 포함하는 경우 함수 타입은 오른쪽에서 왼쪽으로 그룹화 됩니다. 예를 들어 함수 타입 "},{"type":"codeVoice","code":"(Int) -> (Int) -> Int"},{"text":" 는 ","type":"text"},{"type":"codeVoice","code":"(Int) -> ((Int) -> Int)"},{"text":" 로 이해됩니다 — 이 함수는 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 를 가지며 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 가지고 반환하는 다른 함수를 반환합니다."}]},{"type":"paragraph","inlineContent":[{"text":"에러를 던지거나 다시 던질 수 있는 함수 타입은","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"throws"},{"type":"text","text":" 키워드가 포함되어야 합니다."},{"text":" ","type":"text"},{"type":"text","text":"에러의 타입을 지정하기 위해서"},{"type":"text","text":" "},{"code":"throws","type":"codeVoice"},{"text":" 다음 괄호안에 타입을 포함할 수 있습니다.","type":"text"},{"text":" ","type":"text"},{"text":"에러 타입은 ","type":"text"},{"code":"Error","type":"codeVoice"},{"text":" 프로토콜을 준수해야 합니다.","type":"text"},{"text":" ","type":"text"},{"text":"특정 타입이 없이 ","type":"text"},{"type":"codeVoice","code":"throws"},{"type":"text","text":" 를 작성하는 것은"},{"type":"text","text":" "},{"type":"codeVoice","code":"throws(any Error)"},{"type":"text","text":" 로 작성한 것과 같습니다."},{"type":"text","text":" "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" 를 생략하는 것은 "},{"type":"codeVoice","code":"throws(Never)"},{"text":" 로 작성하는 것과 같습니다.","type":"text"},{"type":"text","text":" "},{"text":"함수가 던지는 에러 타입은","type":"text"},{"type":"text","text":" "},{"type":"text","text":"제너릭 타입, 박스형 프로토콜 타입, 그리고 불투명한 타입을 포함하여"},{"type":"text","text":" "},{"code":"Error","type":"codeVoice"},{"type":"text","text":" 를 준수하는 모든 타입일 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"text":"함수가 던지는 에러의 타입은 함수 타입의 일부이고,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"에러 타입 간의 하위 타입 관계는"},{"text":" ","type":"text"},{"type":"text","text":"함수 타입 또한 하위 타입이라는 의미입니다."},{"text":" ","type":"text"},{"type":"text","text":"예를 들어, 임의로 정의한 "},{"type":"codeVoice","code":"MyError"},{"type":"text","text":" 타입을 선언하면,"},{"type":"text","text":" "},{"type":"text","text":"함수 타입 간의 관계는"},{"type":"text","text":" "},{"type":"text","text":"상위 타입에서 하위 타입으로 다음과 같습니다:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 에러를 던지는 함수는 "},{"code":"throws(any Error)","type":"codeVoice"},{"type":"text","text":" 로 표시합니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"특정 에러를 던지는 함수는 ","type":"text"},{"type":"codeVoice","code":"throws(MyError)"},{"text":" 로 표시합니다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"던지지 않는 함수는 "},{"type":"codeVoice","code":"throws(Never)"},{"text":" 로 표시합니다.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 하위 타입 관계의 결과는 다음과 같습니다:"}]},{"items":[{"content":[{"inlineContent":[{"text":"던지는 함수와 동일한 위치에","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"던지지 않는 함수를 사용할 수 있습니다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"던지는 함수와 동일한 위치에"},{"text":" ","type":"text"},{"text":"구체적인 에러 타입을 던지는 함수를 사용할 수 있습니다.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"더 일반적인 에러 타입을 던지는 함수와 동일한 위치에","type":"text"},{"type":"text","text":" "},{"text":"특정 에러 타입을 던지는 함수를 사용할 수 있습니다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입에서 던지는 에러로"},{"type":"text","text":" "},{"text":"연관된 타입 (associated type) 또는 제너릭 타입 파라미터 (generic type parameter) 를 사용하면,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"연관된 타입 또는 제너릭 타입 파라미터는"},{"type":"text","text":" "},{"type":"text","text":"암시적으로 "},{"type":"codeVoice","code":"Error"},{"type":"text","text":" 프로토콜을 준수해야 합니다."},{"text":" ","type":"text"},{"type":"text","text":"던지는 함수와 다시 던지는 함수는"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods","isActive":true},{"type":"text","text":" 와"},{"text":" ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods","type":"reference"},{"text":" 에 설명되어 있습니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"비동기 함수에 대한 함수 타입은 "},{"code":"async","type":"codeVoice"},{"text":" 키워드로 표시되어야 합니다. ","type":"text"},{"type":"codeVoice","code":"async"},{"type":"text","text":" 키워드는 함수의 타입의 부분이며, 동기 함수는 비동기 함수의 하위 타입 (subtypes) 입니다. 결과적으로 비동기 함수와 같은 위치에서 동기 함수를 사용할 수 있습니다. 비동기 함수에 대한 더 자세한 설명은 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods","type":"reference","isActive":true},{"type":"text","text":" 를 참고 바랍니다."}],"type":"paragraph"},{"level":3,"text":"비탈출 클로저에 대한 제한사항 (Restrictions for Nonescaping Closures)","type":"heading","anchor":"%EB%B9%84%ED%83%88%EC%B6%9C-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD-Restrictions-for-Nonescaping-Closures"},{"inlineContent":[{"type":"text","text":"비탈출 함수 (nonescaping function) 인 파라미터는 값이 탈출 될 수 있으므로 타입 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 의 프로퍼티, 변수, 또는 상수에 저장될 수 없습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"비탈출 함수 인 파라미터는 다른 비탈출 함수 파라미터 인수로 전달될 수 없습니다. 이 제한사항은 Swift 가 런타임이 아닌 컴파일 시 메모리에 접근 충돌에 대한 검사를 더 많이 수행하는데 도움이 됩니다. 예를 들어:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let external: (() -> Void) -> Void = { _ in () }","func takesTwoFunctions(first: (() -> Void) -> Void, second: (() -> Void) -> Void) {","    first { first {} }       \/\/ Error","    second { second {}  }    \/\/ Error","","    first { second {} }      \/\/ Error","    second { first {} }      \/\/ Error","","    first { external {} }    \/\/ OK","    external { first {} }    \/\/ OK","}"]},{"inlineContent":[{"text":"위의 코드에서 ","type":"text"},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"type":"text","text":" 에 대한 두 파라미터는 모두 함수입니다. 두 파라미터 모두 "},{"type":"codeVoice","code":"@escaping"},{"text":" 으로 표시되지 않으므로 결과적으로 둘다 비탈출 입니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"위의 예제에서 “Error” 로 표시된 4개의 함수 호출은 컴파일러 에러를 일으킵니다. "},{"type":"codeVoice","code":"first"},{"text":" 와 ","type":"text"},{"type":"codeVoice","code":"second"},{"type":"text","text":" 파라미터는 비탈출 함수이므로 다른 비탈출 함수 파라미터 인수로 전달될 수 없습니다. 반대로 “OK” 로 표시된 2개의 함수 호출은 컴파일러 에러를 발생시키지 않습니다. 이 함수 호출은 "},{"code":"external","type":"codeVoice"},{"type":"text","text":" 이 "},{"code":"takesTwoFunctions(first:second:)","type":"codeVoice"},{"type":"text","text":" 의 파라미터 중 하나가 아니므로 제한사항에 위배되지 않습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"제한사항을 피해야 하는 경우 파라미터 중 하나를 탈출로 표시하거나 "},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"type":"text","text":" 함수를 이용하여 탈출 함수로 비탈출 함수 파라미터 중 하나를 임시로 변경해야 합니다. 메모리에 충돌 접근을 피하는 것에 대한 자세한 내용은 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/MemorySafety","isActive":true,"type":"reference"},{"text":" 을 참고 바랍니다.","type":"text"}]},{"name":"Grammar of a function type","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"function-type"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"attributes","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-clause"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"async","type":"codeVoice"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"throws-clause","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"->"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"function-type-argument-clause","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"function-type-argument-clause","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"text":"function-type-argument-list","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"..."}],"type":"strong"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]}]},{"inlineContent":[{"inlineContent":[{"text":"function-type-argument-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"function-type-argument"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":","}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"function-type-argument-list","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"function-type-argument","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"attributes"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"parameter-modifier","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-label"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"type-annotation","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"argument-label"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"throws-clause"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"throws"}],"type":"strong"},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"code":"throws","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]}]},{"level":2,"text":"배열 타입 (Array Type)","type":"heading","anchor":"%EB%B0%B0%EC%97%B4-%ED%83%80%EC%9E%85-Array-Type"},{"type":"paragraph","inlineContent":[{"text":"Swift 언어는 Swift 표준 라이브러리 ","type":"text"},{"code":"Array<Element>","type":"codeVoice"},{"type":"text","text":" 타입에 대해 다음과 같은 구문을 제공합니다:"}]},{"type":"codeListing","syntax":"swift","code":["[<#type#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 표현으로 다음의 두 선언도 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let someArray: Array<String> = [\"Alex\", \"Brian\", \"Dave\"]","let someArray: [String] = [\"Alex\", \"Brian\", \"Dave\"]"]},{"type":"paragraph","inlineContent":[{"text":"두 경우 모두 상수 someArray 는 문자열의 배열로 선언됩니다. 배열의 요소는 대괄호에 유효한 인덱스 값을 지정하여 서브 스크립트를 통해 접근할 수 있습니다: ","type":"text"},{"type":"codeVoice","code":"someArray[0]"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":" 인 인덱스 0번째 요소를 나타냅니다."}]},{"inlineContent":[{"type":"text","text":"대괄호 쌍을 중첩하여 다차원 배열을 만들 수 있습니다. 여기서 요소의 기본 타입 이름은 가장 안쪽 대괄호 쌍에 포함됩니다. 예를 들어 대괄호 3쌍을 이용하여 정수의 3차원 배열을 생성할 수 있습니다:"}],"type":"paragraph"},{"type":"codeListing","code":["var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"다차원 배열의 요소에 접근할 때 가장 왼쪽에 있는 서브 스크립트 인덱스는 배열의 가장 바깥 쪽에 있는 요소를 참조합니다. 오른쪽에 있는 다음 서브 스크립트 인덱스는 한 차원 더 들어가는 중첩된 배열의 요소를 참조합니다. 이것은 위의 예제에서 "},{"type":"codeVoice","code":"array3D[0]"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"[[1, 2], [3, 4]]"},{"type":"text","text":" 를 참조하고 "},{"type":"codeVoice","code":"array3D[0][1]"},{"type":"text","text":" 은 "},{"code":"[3, 4]","type":"codeVoice"},{"text":" 그리고 ","type":"text"},{"code":"array3D[0][1][1]","type":"codeVoice"},{"text":" 은 값 4를 참조합니다.","type":"text"}]},{"inlineContent":[{"text":"Swift 표준 라이브러리 ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" 타입에 대한 자세한 설명은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays","type":"reference","isActive":true},{"text":" 을 참고 바랍니다.","type":"text"}],"type":"paragraph"},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"array-type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"[","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]}],"type":"paragraph"}],"name":"Grammar of an array type"},{"text":"딕셔너리 타입 (Dictionary Type)","anchor":"%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%ED%83%80%EC%9E%85-Dictionary-Type","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Swift 언어는 Swift 표준 라이브러리 "},{"code":"Dictionary<Key, Value>","type":"codeVoice"},{"text":" 타입에 대해 아래와 같은 구문을 제공합니다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["[<#key type#>: <#value type#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 표현으로 다음의 두 선언도 동일합니다:"}]},{"type":"codeListing","code":["let someDictionary: [String: Int] = [\"Alex\": 31, \"Paul\": 39]","let someDictionary: Dictionary<String, Int> = [\"Alex\": 31, \"Paul\": 39]"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"두 경우 모두 상수 ","type":"text"},{"code":"someDictionary","type":"codeVoice"},{"text":" 는 키로 문자열과 값으로 정수를 가지는 딕셔너리가 선언됩니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"딕셔너리의 값은 대괄호에 해당 키를 지정하여 접근할 수 있습니다: ","type":"text"},{"type":"codeVoice","code":"someDictionary[\"Alex\"]"},{"type":"text","text":" 는 키 "},{"code":"\"Alex\"","type":"codeVoice"},{"type":"text","text":" 와 연관된 값을 참조합니다. 서브 스크립트는 딕셔너리의 값 타입의 옵셔널 값을 반환합니다. 지정한 키가 딕셔너리에 포함되지 않은 경우 서브 스크립트는 "},{"code":"nil","type":"codeVoice"},{"text":" 을 반환합니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"딕셔너리의 키 타입은 Swift 표준 라이브러리 "},{"type":"codeVoice","code":"Hashable"},{"text":" 프로토콜을 준수해야 합니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift 표준 라이브러리 ","type":"text"},{"code":"Dictionary","type":"codeVoice"},{"text":" 타입의 자세한 설명은 ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries","isActive":true},{"type":"text","text":" 를 참고 바랍니다."}],"type":"paragraph"},{"type":"aside","style":"note","name":"Grammar of a dictionary type","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"dictionary-type","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"["}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"]","type":"codeVoice"}],"type":"strong"}]}]},{"anchor":"%EC%98%B5%EC%85%94%EB%84%90-%ED%83%80%EC%9E%85-Optional-Type","type":"heading","level":2,"text":"옵셔널 타입 (Optional Type)"},{"type":"paragraph","inlineContent":[{"text":"Swift 언어는 Swift 표준 라이브러리에 정의된 명명된 타입 ","type":"text"},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 에 대해 접미사 "},{"type":"codeVoice","code":"?"},{"type":"text","text":" 구문을 정의합니다. 다른 표현으로 다음의 두 선언은 동일합니다:"}]},{"code":["var optionalInteger: Int?","var optionalInteger: Optional<Int>"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 경우 모두 변수 "},{"type":"codeVoice","code":"optionalInteger"},{"text":" 는 옵셔널 정수의 타입을 가지도록 선언됩니다. 타입과 ","type":"text"},{"type":"codeVoice","code":"?"},{"text":" 사이에는 공백이 없을 수도 있습니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"text":" 는 존재하거나 존재하지 않을 수 있는 값을 나타내는데 ","type":"text"},{"type":"codeVoice","code":"none"},{"text":" 과 ","type":"text"},{"code":"some(Wrapped)","type":"codeVoice"},{"type":"text","text":" 의 두가지 케이스가 있는 열거형입니다. 모든 타입은 명시적으로 선언되거나 옵셔널 타입으로 암시적으로 변환될 수 있습니다. 옵셔널 변수 또는 프로퍼티를 선언할 때 초기값을 제공하지 않으면 자동으로 "},{"type":"codeVoice","code":"nil"},{"text":" 로 설정합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"옵셔널 타입의 인스턴스는 값을 포함할 경우 아래에서 보듯이 접시마 연산자 ","type":"text"},{"code":"!","type":"codeVoice"},{"type":"text","text":" 를 사용하여 값에 접근할 수 있습니다:"}]},{"syntax":"swift","code":["optionalInteger = 42","optionalInteger! \/\/ 42"],"type":"codeListing"},{"inlineContent":[{"code":"nil","type":"codeVoice"},{"text":" 의 값을 가지는 옵셔널을 언래핑 하기위해 ","type":"text"},{"code":"!","type":"codeVoice"},{"text":" 연산자를 사용하면 런타임 에러가 발생합니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"옵셔널 표현식에 대해 조건부 수행을 위해 옵셔널 체이닝과 옵셔널 바인딩을 사용할 수도 있습니다. 값이 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 인 경우에 작업은 더이상 수행되지 않으므로 런타임 에러가 발생하지 않습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"더 자세한 정보와 옵셔널 타입 사용에 대한 예제를 보려면 ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals"},{"type":"text","text":" 을 참고 바랍니다."}]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-type"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"?"}],"type":"strong"}],"type":"paragraph"}],"style":"note","name":"Grammar of an optional type","type":"aside"},{"type":"heading","text":"암시적으로 언래핑된 옵셔널 타입 (Implicitly Unwrapped Optional Type)","level":2,"anchor":"%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-%ED%83%80%EC%9E%85-Implicitly-Unwrapped-Optional-Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 언어는 옵셔널 타입에 접근할 때 자동으로 언래핑된 동작을 추가하기 위해 Swift 표준 라이브러리에 정의된 명명된 타입 "},{"code":"Optional<Wrapped>","type":"codeVoice"},{"type":"text","text":" 에 대한 접미사 "},{"type":"codeVoice","code":"!"},{"text":" 구문을 정의합니다. ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 의 값을 가지는 옵셔널에 암시적 언래핑을 사용하려고 하면 런타임 에러가 발생합니다. 암시적 언래핑 동작을 제외하고 다음의 두 선언은 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["var implicitlyUnwrappedString: String!","var explicitlyUnwrappedString: Optional<String>"]},{"inlineContent":[{"type":"text","text":"타입과 "},{"type":"codeVoice","code":"!"},{"type":"text","text":" 사이에 공백이 포함되지 않을 수 있습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"암시적 언래핑은 해당 타입을 포함하는 선언의 의미를 변경하기 때문에 튜플 타입 또는 딕셔너리 또는 배열의 요소 타입과 같이 제너릭 타입 내에 중첩된 옵셔널 타입은 암시적 언래핑으로 표시할 수 없습니다. 예를 들어:","type":"text"}]},{"type":"codeListing","code":["let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  \/\/ Error","let implicitlyUnwrappedTuple: (Int, Int)!             \/\/ OK","","let arrayOfImplicitlyUnwrappedElements: [Int!]        \/\/ Error","let implicitlyUnwrappedArray: [Int]!                  \/\/ OK"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널은 옵셔널 값과 동일한 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"text":" 타입을 가지므로 옵셔널을 사용할 수 있는 코드에서 동일한 위치에서 암시적으로 언래핑된 옵셔널을 사용할 수 있습니다. 예를 들어 옵셔널의 변수, 상수, 그리고 프로퍼티에 암시적으로 언래핑된 옵셔널의 값을 할당할 수 있고 그 반대도 가능합니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"옵셔널과 마찬가지로 암시적으로 언래핑된 옵셔널 변수 또는 프로퍼티를 선언할 때 초기값을 제공하지 않으면 자동으로 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 을 기본값으로 설정합니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널 표현식에 조건부로 동작을 수행하려면 옵셔널 체이닝을 사용합니다. 값이 "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" 이라면 더이상 작업이 수행되지 않으며 런타임 에러가 발생하지 않습니다."}]},{"type":"paragraph","inlineContent":[{"text":"암시적으로 언래핑된 옵셔널 타입에 대한 자세한 정보는 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals","isActive":true,"type":"reference"},{"type":"text","text":" 을 참고 바랍니다."}]},{"type":"aside","name":"Grammar of an implicitly unwrapped optional type","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"implicitly-unwrapped-optional-type","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"!","type":"codeVoice"}]}]}]},{"level":2,"type":"heading","text":"프로토콜 혼합 타입 (Protocol Composition Type)","anchor":"%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%ED%98%BC%ED%95%A9-%ED%83%80%EC%9E%85-Protocol-Composition-Type"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"프로토콜 혼합 타입 (protocol composition type)","type":"text"}]},{"text":" 은 지정된 프로토콜의 리스트에서 각 프로토콜을 준수하는 타입 또는 주어진 클래스의 하위 클래스와 지정된 프로토콜의 리스트애서 각 프로토콜을 준수하는 타입을 정의합니다. 프로토콜 혼합 타입은 타입 주석, 제너릭 파라미터 절, 그리고 제너릭 ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" 절을 지정할 때만 사용할 수 있습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"프로토콜 혼합 타입은 다음의 형식을 가집니다:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["<#Protocol 1#> & <#Protocol 2#>"]},{"inlineContent":[{"type":"text","text":"프로토콜 혼합 타입을 사용하면 타입이 준수하려는 각 프로토콜에서 상속되는 명명된 프로토콜을 새롭게 명시적으로 정의하지 않아도 타입이 여러 프로토콜의 요구사항을 준수하는 값을 지정할 수 있습니다. 예를 들어 "},{"code":"ProtocolA","type":"codeVoice"},{"text":", ","type":"text"},{"code":"ProtocolB","type":"codeVoice"},{"type":"text","text":", 그리고 "},{"code":"ProtocolC","type":"codeVoice"},{"type":"text","text":" 를 상속하는 새로운 프로토콜을 선언하는 대신 프로토콜 혼합 타입 "},{"type":"codeVoice","code":"ProtocolA & ProtocolB & ProtocolC"},{"type":"text","text":" 를 사용할 수 있습니다. 마찬가지로 "},{"code":"SuperClass","type":"codeVoice"},{"text":" 의 하위 클래스와 ","type":"text"},{"type":"codeVoice","code":"ProtocolA"},{"type":"text","text":" 를 준수하는 새로운 프로토콜을 선언하는 대신에 "},{"code":"SuperClass & ProtocolA","type":"codeVoice"},{"type":"text","text":" 를 사용할 수 있습니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"프로토콜 혼합 리스트에 각 항목은 다음 중 하나입니다; 이 리스트는 최대 하나의 클래스를 포함할 수 있습니다:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"클래스의 이름","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"프로토콜의 이름"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"기본 타입이 프로토콜 구성 타입, 프로토콜, 또는 클래스 인 타입 별칭"}]}]}]},{"inlineContent":[{"type":"text","text":"프로토콜 혼합 타입이 타입 별칭을 포함할 때 동일한 프로토콜이 정의에 중복해서 나타날 수 있으며 중복은 무시됩니다. 예를 들어 아래 코드에서 "},{"type":"codeVoice","code":"PQR"},{"type":"text","text":" 의 정의는 "},{"code":"P & Q & R","type":"codeVoice"},{"text":" 과 동일합니다.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["typealias PQ = P & Q","typealias PQR = PQ & Q & R"],"type":"codeListing"},{"type":"aside","style":"note","name":"Grammar of a protocol composition type","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"protocol-composition-type","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-identifier","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"&"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-continuation"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"protocol-composition-continuation"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"protocol-composition-type"}],"type":"emphasis"}]}]},{"text":"불투명한 타입 (Opaque Type)","type":"heading","level":2,"anchor":"%EB%B6%88%ED%88%AC%EB%AA%85%ED%95%9C-%ED%83%80%EC%9E%85-Opaque-Type"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"불투명한 타입 (opaque type)"}]},{"type":"text","text":" 은 기본 타입 지정없이 프로토콜 또는 프로토콜 구성을 준수하는 타입을 정의합니다."}],"type":"paragraph"},{"inlineContent":[{"text":"불투명한 타입은 함수 또는 서브 스크립트의 반환타입 또는 프로퍼티의 타입으로 나타납니다. 불투명한 타입은 배열의 요소 타입 또는 옵셔널의 래핑된 타입과 같은 튜플 타입 또는 제너릭 타입의 부분으로 나타날 수 없습니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"불투명 타입은 다음의 형식을 가집니다:","type":"text"}],"type":"paragraph"},{"code":["some <#constraint#>"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"inlineContent":[{"text":"제약조건 (constraint)","type":"text"}],"type":"emphasis"},{"text":" 은 클래스 타입, 프로토콜 타입, 프로토콜 구성 타입, 또는 ","type":"text"},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 입니다. 값은 나열된 프로토콜 또는 프로토콜 구성을 준수하는 타입의 인스턴스나 나열된 클래스를 상속하는 경우에만 불투명한 타입의 인스턴스로 사용될 수 있습니다. 불투명한 값과 상호작용하는 코드는 "},{"inlineContent":[{"text":"제약조건 (constraint)","type":"text"}],"type":"emphasis"},{"text":" 에 의해 정의된 인터페이스의 일부의 방식으로만 값으로 사용할 수 있습니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"컴파일 시간에 타입이 불투명한 값은 특정한 구체적인 타입을 가지며, Swift 는 최적화를 위해 기본 타입을 사용할 수 있습니다. 그러나, 불투명한 타입은 기본 타입에 대한 정보를 교류할 수 없는 경계의 형식을 가집니다."}]},{"type":"paragraph","inlineContent":[{"text":"프로토콜 선언은 불투명한 타입을 포함할 수 없습니다. 클래스는 비final 메서드 (nonfinal method) 의 반환 타입으로 불투명한 타입을 사용할 수 없습니다.","type":"text"}]},{"inlineContent":[{"text":"불투명한 타입을 반환 타입으로 사용하는 함수는 단일 기본 타입을 공유하는 값을 반환해야 합니다. 반환 타입은 함수의 제너릭 타입 파라미터의 부분인 타입을 포함할 수 있습니다. 예를 들어 함수 ","type":"text"},{"type":"codeVoice","code":"someFunction<T>()"},{"text":" 는 타입 ","type":"text"},{"code":"T","type":"codeVoice"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Dictionary<String, T>"},{"text":" 의 값을 반환할 수 있습니다.","type":"text"}],"type":"paragraph"},{"type":"aside","name":"Grammar of an opaque type","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"opaque-type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"some"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]}],"style":"note"},{"anchor":"%EB%B0%95%EC%8A%A4%ED%98%95-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%ED%83%80%EC%9E%85-Boxed-Protocol-Type","text":"박스형 프로토콜 타입 (Boxed Protocol Type)","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"박스형 프로토콜 타입 (Boxed Protocol Type) 은 프로토콜 또는 프로토콜 혼합을 준수하는 타입을 정의하고 준수하는 타입이 프로그램 실행 중에 변경될 수 있습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"박스형 프로토콜 타입은 아래와 같은 형식을 가집니다:"}]},{"syntax":"swift","type":"codeListing","code":["any <#constraint#>"]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"제약","type":"text"}]},{"text":" 은 프로토콜 타입, 프로토콜 혼합 타입, 프로토콜 타입의 메타타입, 또는 프로토콜 혼합 타입의 메타타입입니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"런타임에 박스형 프로토콜 타입의 인스턴스는 제약조건에 충족하는 모든 타입의 값을 포함할 수 있습니다. 이런 동작은 불투명한 타입 (opaque type) 동작과 대조되고 컴파일 시간에 알고있는 준수하는 타입이 있습니다. 박스형 프로토콜 타입으로 사용되는 추가 간접수준을 ","type":"text"},{"type":"codeVoice","code":"boxing"},{"text":" 이라 합니다. 박싱 (Boxing) 은 일반적으로 저장을 위한 별도의 메모리 할당과 접근에 대한 추가적인 간접수준을 필요로 하므로 런타임 시 비용이 발생합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Any"},{"type":"text","text":" 또는 "},{"code":"AnyObject","type":"codeVoice"},{"text":" 타입은 이미 박스형 프로토콜 타입이므로 ","type":"text"},{"type":"codeVoice","code":"any"},{"type":"text","text":" 를 적용해도 아무런 효과가 없습니다."}]},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"Grammar of a boxed protocol type"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"boxed-protocol-type"}],"type":"emphasis"},{"type":"text","text":" –> "},{"inlineContent":[{"code":"any","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]}]},{"text":"메타타입 타입 (Metatype Type)","level":2,"anchor":"%EB%A9%94%ED%83%80%ED%83%80%EC%9E%85-%ED%83%80%EC%9E%85-Metatype-Type","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"메타타입 타입 (metatype type)","type":"text"}]},{"text":" 은 클래스 타입, 구조체 타입, 열거형 타입, 그리고 프로토콜 타입을 포함하여 모든 타입의 타입을 나타냅니다.","type":"text"}]},{"inlineContent":[{"text":"클래스, 구조체, 또는 열거형 타입의 메타타입은 해당 타입의 이름 다음에 ","type":"text"},{"type":"codeVoice","code":".Type"},{"type":"text","text":" 을 붙입니다. 런타임 시 프로토콜을 준수하는 구체적인 타입이 아닌 프로토콜 타입의 메타타입은 프로토콜의 이름 다음에 "},{"type":"codeVoice","code":".Protocol"},{"type":"text","text":" 을 붙입니다. 예를 들어 클래스 타입 "},{"type":"codeVoice","code":"SomeClass"},{"text":" 의 메타타입은 ","type":"text"},{"type":"codeVoice","code":"SomeClass.Type"},{"type":"text","text":" 그리고 프로토콜 "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" 의 메타타입은 "},{"type":"codeVoice","code":"SomeProtocol.Protocol"},{"type":"text","text":" 입니다."}],"type":"paragraph"},{"inlineContent":[{"text":"접미사 ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" 표현식을 사용하여 타입을 값으로 접근할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"SomeClass.self"},{"text":" 는 ","type":"text"},{"code":"SomeClass","type":"codeVoice"},{"type":"text","text":" 의 인스턴스가 아닌 "},{"code":"SomeClass","type":"codeVoice"},{"text":" 자체를 반환합니다. 그리고 ","type":"text"},{"code":"SomeProtocol.self","type":"codeVoice"},{"type":"text","text":" 는 런타임 시 "},{"type":"codeVoice","code":"SomeProtocol"},{"text":" 을 준수하는 타입의 인스턴스가 아닌 ","type":"text"},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" 자체를 반환합니다. 다음 예제와 같이 타입의 인스턴스와 함께 "},{"code":"type(of:)","type":"codeVoice"},{"type":"text","text":" 함수를 호출하여 해당 인스턴스의 동적으로 런타임 타입의 값으로 접근할 수 있습니다:"}],"type":"paragraph"},{"code":["class SomeBaseClass {","    class func printClassName() {","        print(\"SomeBaseClass\")","    }","}","class SomeSubClass: SomeBaseClass {","    override class func printClassName() {","        print(\"SomeSubClass\")","    }","}","let someInstance: SomeBaseClass = SomeSubClass()","\/\/ The compile-time type of someInstance is SomeBaseClass,","\/\/ and the runtime type of someInstance is SomeSubClass","type(of: someInstance).printClassName()","\/\/ Prints \"SomeSubClass\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"자세한 내용은 Swift 표준 라이브러리에 ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","isActive":true},{"text":" 을 참고 바랍니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"초기화 구문 표현식을 사용하여 해당 타입의 메타타입 값에서 타입의 인스턴스를 생성합니다. 클래스 인스턴스의 경우 호출되는 초기화 구문은 ","type":"text"},{"type":"codeVoice","code":"required"},{"text":" 키워드로 표시거나 ","type":"text"},{"type":"codeVoice","code":"final"},{"type":"text","text":" 키워드로 전체 클래스를 표시해야 합니다."}],"type":"paragraph"},{"code":["class AnotherSubClass: SomeBaseClass {","    let string: String","    required init(string: String) {","        self.string = string","    }","    override class func printClassName() {","        print(\"AnotherSubClass\")","    }","}","let metatype: AnotherSubClass.Type = AnotherSubClass.self","let anotherInstance = metatype.init(string: \"some string\")"],"type":"codeListing","syntax":"swift"},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"metatype-type","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"code":"Type","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Protocol"}]}]}],"name":"Grammar of a metatype type","type":"aside","style":"note"},{"level":2,"type":"heading","anchor":"Any-%ED%83%80%EC%9E%85-Any-Type","text":"Any 타입 (Any Type)"},{"type":"paragraph","inlineContent":[{"code":"Any","type":"codeVoice"},{"type":"text","text":" 타입은 다른 모든 타입의 값을 포함할 수 있습니다. "},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 는 다음 타입의 인스턴스에 대해 구체적인 타입으로 사용될 수 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스, 구조체, 또는 열거형"}]}]},{"content":[{"inlineContent":[{"code":"Int.self","type":"codeVoice"},{"text":" 와 같은 메타타입","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 타입의 구성요소가 있는 튜플"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"클로저 또는 함수 타입"}],"type":"paragraph"}]}]},{"syntax":"swift","code":["let mixed: [Any] = [\"one\", 2, true, (4, 5.3), { () -> Int in return 6 }]"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"인스턴스에 대해 구체적인 타입으로 "},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 를 사용할 때 해당 프로퍼티 또는 메서드에 접근하려면 먼저 알려진 타입으로 인스턴스를 캐스팅 해야 합니다. "},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 의 구체적인 타입인 인스턴스는 본래 동적 타입을 유지하고 "},{"type":"codeVoice","code":"as"},{"text":", ","type":"text"},{"type":"codeVoice","code":"as?"},{"text":", 또는 ","type":"text"},{"type":"codeVoice","code":"as!"},{"type":"text","text":" 와 같은 타입 캐스팅 연산자 (type-cast operators) 중 하나를 사용하여 타입을 캐스팅 할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"as?"},{"text":" 을 사용하여 배열의 첫번째 객체를 ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" 으로 조건부로 다운캐스트 합니다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["if let first = mixed.first as? String {","    print(\"The first item, '\\(first)', is a string.\")","}","\/\/ Prints \"The first item, 'one', is a string.\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"캐스팅에 대한 자세한 내용은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting","type":"reference","isActive":true},{"text":" 을 참고 바랍니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"AnyObject","type":"codeVoice"},{"text":" 프로토콜은 ","type":"text"},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 타입과 유사합니다. 모든 클래스는 암시적으로 "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" 를 준수합니다. 언어에 의해 정의되는 "},{"type":"codeVoice","code":"Any"},{"text":" 와 달리 ","type":"text"},{"code":"AnyObject","type":"codeVoice"},{"text":" 는 Swift 표준 라이브러리에 의해 정의됩니다. 더 자세한 내용은 ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols","type":"reference"},{"text":" 과 ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","isActive":true,"type":"reference"},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"aside","name":"Grammar of an Any type","style":"note","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"any-type"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"Any"}],"type":"strong"}],"type":"paragraph"}]},{"level":2,"type":"heading","anchor":"Self-%ED%83%80%EC%9E%85-Self-Type","text":"Self 타입 (Self Type)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 특정 타입이 아니라 해당 타입의 이름을 반복하거나 알지 않아도 현재 타입을 편리하게 참조할 수 있습니다."}]},{"inlineContent":[{"text":"프로토콜 선언 또는 프로토콜 멤버 선언에서 ","type":"text"},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 프로토콜을 준수하는 최종 타입을 나타냅니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"구조체, 클래스, 또는 열거형 선언에서 "},{"type":"codeVoice","code":"Self"},{"text":" 타입은 선언에 의해 도입된 타입을 참조합니다. 타입의 멤버에 대한 선언 내에서 ","type":"text"},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 해당 타입을 참조합니다. 클래스 선언의 멤버에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 는 다음을 나타낼 수 있습니다:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"메서드의 반환 타입","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"읽기전용 서브 스크립트의 반환 타입"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"읽기전용 계산된 프로퍼티의 타입","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"메서드의 본문"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"예를 들어 아래의 코드는 반환 타입이 "},{"code":"Self","type":"codeVoice"},{"text":" 인 인스턴스 메서드 ","type":"text"},{"code":"f","type":"codeVoice"},{"type":"text","text":" 를 보여줍니다."}]},{"type":"codeListing","code":["class Superclass {","    func f() -> Self { return self }","}","let x = Superclass()","print(type(of: x.f()))","\/\/ Prints \"Superclass\"","","class Subclass: Superclass { }","let y = Subclass()","print(type(of: y.f()))","\/\/ Prints \"Subclass\"","","let z: Superclass = Subclass()","print(type(of: z.f()))","\/\/ Prints \"Subclass\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"위의 예제의 마지막 부분은 ","type":"text"},{"code":"Self","type":"codeVoice"},{"type":"text","text":" 가 변수 자체의 컴파일 타임 타입 (compile-time type) "},{"type":"codeVoice","code":"Superclass"},{"text":" 가 아닌 ","type":"text"},{"code":"z","type":"codeVoice"},{"type":"text","text":" 값의 런타임 타입 (runtime type) "},{"type":"codeVoice","code":"Subclass"},{"text":" 를 참조하는 것을 보여줍니다.","type":"text"}]},{"inlineContent":[{"text":"중첩된 타입 선언 내에서 ","type":"text"},{"code":"Self","type":"codeVoice"},{"text":" 타입은 가장 안쪽 타입 선언에 의해 도입된 타입을 참조합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 Swift 표준 라이브러리에서 "},{"overridingTitleInlineContent":[{"code":"type(of:)","type":"codeVoice"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","type":"reference","isActive":true,"overridingTitle":"type(of:)"},{"text":" 함수와 동일한 타입을 참조합니다. 현재 타입의 멤버를 접근하기 위해 ","type":"text"},{"type":"codeVoice","code":"Self.someStaticMember"},{"type":"text","text":" 라고 작성하는 것은 "},{"type":"codeVoice","code":"type(of:self).someStaticMember"},{"type":"text","text":" 로 작성하는 것과 동일합니다."}]},{"name":"Grammar of a Self type","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"self-type"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"Self","type":"codeVoice"}]}]}]},{"anchor":"%ED%83%80%EC%9E%85-%EC%83%81%EC%86%8D-%EC%A0%88-Type-Inheritance-Clause","text":"타입 상속 절 (Type Inheritance Clause)","type":"heading","level":2},{"inlineContent":[{"inlineContent":[{"type":"text","text":"타입 상속 절 (type inheritance clause)"}],"type":"emphasis"},{"type":"text","text":" 은 명명된 타입이 상속하는 클래스와 명명된 타입이 준수하는 프로토콜을 지정하기 위해 사용됩니다. 타입 상속 절은 콜론 ("},{"code":":","type":"codeVoice"},{"type":"text","text":") 으로 시작하고 그 뒤에 타입 식별자의 리스트가 옵니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"클래스 타입은 단일 상위 클래스를 상속할 수 있고 여러개의 프로토콜을 준수할 수 있습니다. 클래스를 정의할 때 상위 클래스의 이름은 타입 식별자의 리스트에서 첫번째로 나타나야 하고 다음으로 준수하는 여러개의 프로토콜이 옵니다. 클래스가 다른 클래스를 상속하지 않으면 리스트는 대신 프로토콜로 시작할 수 있습니다. 클래스 상속에 대한 자세한 설명과 예제는 "},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Inheritance","type":"reference"},{"text":" 을 참고 바랍니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"다른 명명된 타입은 프로토콜의 리스트에서 상속하거나 준수할 수 있습니다. 프로토콜 타입은 여러 다른 프로토콜을 상속할 수 있습니다. 프로토콜 타입은 다른 프로토콜을 상속할 때 다른 프로토콜의 요구사항을 모으고 현재 프로토콜에서 상속되는 모든 타입은 모든 요구사항을 준수해야 합니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"열거형 정의에 타입 상속 절은 프로토콜의 리스트이거나 케이스에 원시값 (raw values) 을 할당하는 열거형인 경우 해당 원시값의 타입을 지정하는 단일 명명된 타입일 수 있습니다. 타입 상속 절을 사용하여 원시값의 타입을 지정하는 열거형 정의의 예는 ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values"},{"text":" 을 참고 바랍니다.","type":"text"}]},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"text":"type-inheritance-clause","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-inheritance-list","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"attributes","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"attributes"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type-identifier"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]}],"type":"paragraph"}],"name":"Grammar of a type inheritance clause"},{"type":"heading","level":2,"anchor":"%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0-Type-Inference","text":"타입 추론 (Type Inference)"},{"inlineContent":[{"type":"text","text":"Swift 는 광범위하게 "},{"type":"emphasis","inlineContent":[{"text":"타입 추론 (type inference)","type":"text"}]},{"text":" 을 사용하므로 코드에서 많은 변수와 표현식의 타입 또는 타입의 부분을 생략할 수 있습니다. 예를 들어 ","type":"text"},{"type":"codeVoice","code":"var x: Int = 0"},{"text":" 으로 작성하는 대신에 ","type":"text"},{"type":"codeVoice","code":"var x = 0"},{"type":"text","text":" 으로 타입을 완벽하게 생략하고 작성할 수 있습니다 — 컴파일러는 "},{"code":"x","type":"codeVoice"},{"type":"text","text":" 를 타입 "},{"type":"codeVoice","code":"Int"},{"text":" 의 값으로 추론합니다. 유사하게 컨텍스트에서 전체 타입이 추론될 수 있을 때 타입의 부분을 생략할 수 있습니다. 예를 들어 ","type":"text"},{"type":"codeVoice","code":"let dict: Dictionary = [\"A\": 1]"},{"type":"text","text":" 을 작성하면 컴파일러는 "},{"code":"dict","type":"codeVoice"},{"type":"text","text":" 이 타입 "},{"code":"Dictionary<String, Int>","type":"codeVoice"},{"text":" 이라고 추론합니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"위의 두 예제에서 타입 정보는 표현식 트리의 잎에서 루트까지 전달됩니다. 즉, "},{"code":"var x: Int = 0","type":"codeVoice"},{"type":"text","text":" 에서 "},{"code":"x","type":"codeVoice"},{"text":" 의 타입은 먼저 ","type":"text"},{"type":"codeVoice","code":"0"},{"text":" 의 타입을 확인한 다음에 이 타입 정보를 루트 (변수 ","type":"text"},{"type":"codeVoice","code":"x"},{"type":"text","text":") 까지 전달하여 추론합니다."}],"type":"paragraph"},{"inlineContent":[{"text":"Swift 에서 타입 정보는 루트에서 잎까지 반대로 흐를 수도 있습니다. 예를 들어 다음 예제에서 상수 ","type":"text"},{"type":"codeVoice","code":"eFloat"},{"text":" 에 명시적 타입 주석 (","type":"text"},{"type":"codeVoice","code":": Float"},{"type":"text","text":") 은 숫자 리터럴 "},{"code":"2.71828","type":"codeVoice"},{"type":"text","text":" 이 "},{"type":"codeVoice","code":"Double"},{"text":" 이 아닌 ","type":"text"},{"code":"Float","type":"codeVoice"},{"type":"text","text":" 타입을 유추하도록 합니다."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let e = 2.71828 \/\/ The type of e is inferred to be Double.","let eFloat: Float = 2.71828 \/\/ The type of eFloat is Float."]},{"type":"paragraph","inlineContent":[{"text":"Swift 에서 타입 추론은 단일 표현식 또는 구문 수준에서 동작합니다. 이것은 표현식에서 생략된 타입 또는 타입의 일부를 추론하는데 필요한 모든 정보는 표현식 또는 하위 표현식 중 하나를 타입 검사 (type-checking) 하여 접근할 수 있습니다.","type":"text"}]}],"kind":"content"}],"sections":[],"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TypeCasting":{"kind":"article","url":"\/documentation\/the-swift-programming-language-korean\/typecasting","role":"article","abstract":[{"type":"text","text":"값의 런타임 타입을 정하고 타입의 정보를 제공합니다."}],"type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting","title":"타입 캐스팅 (Type Casting)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries":{"kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries","title":"딕셔너리 (Dictionaries)","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/MemorySafety":{"url":"\/documentation\/the-swift-programming-language-korean\/memorysafety","title":"메모리 안전성 (Memory Safety)","kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/MemorySafety","abstract":[{"type":"text","text":"메모리 접근할 때 충돌을 피하기위해 코드를 구조화합니다."}],"role":"article","type":"topic"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values":{"url":"\/documentation\/the-swift-programming-language-korean\/functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","abstract":[],"type":"topic","kind":"section","title":"여러개의 반환값이 있는 함수 (Functions with Multiple Return Values)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters":{"url":"\/documentation\/the-swift-programming-language-korean\/functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters","kind":"section","abstract":[],"type":"topic","title":"가변 파라미터 (Variadic Parameters)","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals":{"title":"암시적으로 언래핑된 옵셔널 (Implicitly Unwrapped Optionals)","kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures":{"url":"\/documentation\/the-swift-programming-language-korean\/closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures","abstract":[],"type":"topic","kind":"section","title":"자동 클로저 (Autoclosures)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals":{"url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals","abstract":[],"type":"topic","kind":"section","title":"옵셔널 (Optionals)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Inheritance":{"url":"\/documentation\/the-swift-programming-language-korean\/inheritance","title":"상속 (Inheritance)","kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Inheritance","abstract":[{"type":"text","text":"기능을 추가 또는 재정의 하기 위한 하위 클래스 입니다."}],"role":"article","type":"topic"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods":{"url":"\/documentation\/the-swift-programming-language-korean\/declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods","abstract":[],"type":"topic","kind":"section","title":"비동기 함수와 메서드 (Asynchronous Functions and Methods)"},"https://developer.apple.com/documentation/swift/anyobject":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","type":"link","titleInlineContent":[{"code":"AnyObject","type":"codeVoice"}],"title":"AnyObject"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods":{"url":"\/documentation\/the-swift-programming-language-korean\/declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods","abstract":[],"type":"topic","kind":"section","title":"다시 던지는 함수와 메서드 (Rethrowing Functions and Methods)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration":{"url":"\/documentation\/the-swift-programming-language-korean\/declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration","abstract":[],"type":"topic","kind":"section","title":"확장 선언 (Extension Declaration)"},"doc://org.swift.tsplk/documentation/TSPLK":{"url":"\/documentation\/tsplk","identifier":"doc:\/\/org.swift.tsplk\/documentation\/TSPLK","type":"topic","kind":"article","role":"collection","title":"The Swift Programming Language (6) (한국어)","abstract":[]},"https://developer.apple.com/documentation/swift/2885064-type":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","type":"link","titleInlineContent":[{"type":"codeVoice","code":"type(of:)"}],"title":"type(of:)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays":{"type":"topic","abstract":[],"title":"배열 (Arrays)","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes#%EB%B0%B0%EC%97%B4-Arrays","kind":"section"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters":{"kind":"section","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters","title":"In-Out 파라미터 (In-Out Parameters)","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values":{"url":"\/documentation\/the-swift-programming-language-korean\/enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values","abstract":[],"type":"topic","kind":"section","title":"원시값 (Raw Values)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods":{"url":"\/documentation\/the-swift-programming-language-korean\/declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods","abstract":[],"type":"topic","kind":"section","title":"함수와 메서드 던지기 (Throwing Functions and Methods)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols":{"url":"\/documentation\/the-swift-programming-language-korean\/protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols","abstract":[],"type":"topic","kind":"section","title":"클래스 전용 프로토콜 (Class-Only Protocols)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Extensions":{"type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions","kind":"article","role":"article","url":"\/documentation\/the-swift-programming-language-korean\/extensions","abstract":[{"text":"기존 타입에 기능을 추가합니다.","type":"text"}],"title":"확장 (Extensions)"}}}