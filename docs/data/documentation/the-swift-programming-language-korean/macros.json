{"schemaVersion":{"minor":3,"patch":0,"major":0},"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/TSPLK"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Macros"},"sections":[],"abstract":[{"type":"text","text":"컴파일 때 코드를 생성하기 위해 매크로를 사용합니다."}],"kind":"article","primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"매크로 (Macro) 는 소스코드를 컴파일 할 때 변환하므로 반복적인 코드를 직접 작성하지 않아도 됩니다. 컴파일하는 동안 Swift 코드를 빌드하기 전에 코드에 모든 매크로를 확장합니다."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"macro-expansion"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"매크로 확장은 항상 추가 작업입니다: 매크로는 새로운 코드를 추가하지만, 기존의 코드를 절대 삭제 또는 수정하지 않습니다."}]},{"type":"paragraph","inlineContent":[{"text":"매크로 입력과 매크로 확장의 출력은 구문적으로 Swift 코드가 유효한지 확인됩니다. 마찬가지로 매크로에 전달하는 값과 매크로에 의해 생성된 코드의 값이 올바른 타입인지 확인됩니다. 추가적으로 매크로를 확장할 때 매크로의 구현에서 오류가 발생하면 컴파일러는 컴파일 오류로 처리합니다. 이러한 보장은 매크로를 사용하는 코드에 대해 더 쉽게 추론할 수 있으며, 매크로를 잘못 사용하거나 매크로 구현에 버그가 있는 경우 이러한 문제를 쉽게 알 수 있습니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Swift 는 두 종류의 매크로를 가지고 있습니다:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"독립 매크로 (Freestanding macro)","type":"text"}]},{"type":"text","text":" 는 선언에 첨부되지 않고 자체적으로 나타납니다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"첨부 매크로 (Attached macro)","type":"text"}]},{"type":"text","text":" 는 매크로가 첨부된 선언을 수정합니다."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"첨부 매크로와 독립 매크로는 약간 다르게 호출하지만 모두 매크로 확장에 대해 동일한 모델을 따르고 동일한 접근방식을 사용하여 구현합니다. 다음 섹션에서 해당 두 종류 매크로에 대해 더 자세히 설명합니다."}]},{"type":"heading","text":"독립 매크로 (Freestanding Macros)","level":2,"anchor":"%EB%8F%85%EB%A6%BD-%EB%A7%A4%ED%81%AC%EB%A1%9C-Freestanding-Macros"},{"type":"paragraph","inlineContent":[{"type":"text","text":"독립 매크로 (freestanding macro) 를 호출하기 위해 이름 앞에 숫자 기호 ("},{"code":"#","type":"codeVoice"},{"text":") 를 작성하고 이름 뒤 소괄호 안에 매크로의 인자를 작성합니다. 예를 들어:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["func myFunction() {","    print(\"Currently running \\(#function)\")","    #warning(\"Something's wrong\")","}"]},{"inlineContent":[{"type":"text","text":"첫번재 줄에서 "},{"type":"codeVoice","code":"#function"},{"type":"text","text":" 은 Swift 표준 라이브러리에 "},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/function()","type":"reference"},{"text":" 을 호출합니다. 이 코드를 컴파일 할 때 Swift 는 ","type":"text"},{"type":"codeVoice","code":"#function"},{"type":"text","text":" 을 현재 함수의 이름으로 대체하는 매크로의 구현을 호출합니다. 이 코드를 실행하고 "},{"code":"myFunction()","type":"codeVoice"},{"type":"text","text":" 을 호출할 때 “Currently running myFunction()” 을 보여줍니다. 두번째 줄에서 "},{"code":"#warning","type":"codeVoice"},{"text":" 은 Swift 표준 라이브러리에서 ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/warning(_:)"},{"text":" 매크로를 호출하여 사용자 지정 컴파일 경고를 생성합니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"독립 매크로는 ","type":"text"},{"type":"codeVoice","code":"#function"},{"type":"text","text":" 과 같이 값을 생성하거나 "},{"type":"codeVoice","code":"#warning"},{"text":" 과 같이 컴파일 때 동작을 수행할 수 있습니다.","type":"text"}],"type":"paragraph"},{"text":"첨부 매크로 (Attached Macros)","type":"heading","level":2,"anchor":"%EC%B2%A8%EB%B6%80-%EB%A7%A4%ED%81%AC%EB%A1%9C-Attached-Macros"},{"type":"paragraph","inlineContent":[{"type":"text","text":"첨부 매크로 (attached macro) 를 호출하려면 매크로 이름 앞에 기호 ("},{"code":"@","type":"codeVoice"},{"type":"text","text":") 를 작성하고 매크로 이름 뒤 소괄호에 인자를 작성합니다."}]},{"inlineContent":[{"text":"첨부 매크로는 첨부된 선언을 수정합니다. 새로운 메서드를 정의하거나 프로토콜의 준수성을 추가하는 것과 같이 해당 선언에 코드를 추가합니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"예를 들어, 매크로를 사용하지 않는 다음의 코드를 살펴봅시다:"}],"type":"paragraph"},{"syntax":"swift","code":["struct SundaeToppings: OptionSet {","    let rawValue: Int","    static let nuts = SundaeToppings(rawValue: 1 << 0)","    static let cherry = SundaeToppings(rawValue: 1 << 1)","    static let fudge = SundaeToppings(rawValue: 1 << 2)","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 코드에서 "},{"type":"codeVoice","code":"SundaeToppings"},{"type":"text","text":" 옵션 셋의 각 옵션은 반복적이고 수동적인 이니셜라이저 호출을 포함합니다. 이러한 코드는 줄 끝에 잘못된 숫자를 입력하는 것과 같은 새로운 옵션을 추가할 때 실수하기 쉽습니다."}]},{"type":"paragraph","inlineContent":[{"text":"다음의 코드는 매크로를 사용한 버전입니다:","type":"text"}]},{"code":["@OptionSet<Int>","struct SundaeToppings {","    private enum Options: Int {","        case nuts","        case cherry","        case fudge","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"이 버전의 ","type":"text"},{"code":"SundaeToppings","type":"codeVoice"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"@OptionSet"},{"text":" 매크로를 호출합니다. 이 매크로는 private 열거형에 케이스의 목록을 읽고 각 옵션에 대한 상수 목록을 생성하고 ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optionset","isActive":true},{"type":"text","text":" 프로토콜의 준수성을 추가합니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"비교를 위해 "},{"code":"@OptionSet","type":"codeVoice"},{"text":" 매크로의 확장 버전은 다음과 같습니다. 이 코드를 작성하지 않고 매크로의 확장을 보기위해 Swift 에 요청한 경우에만 볼 수 있습니다.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct SundaeToppings {","    private enum Options: Int {","        case nuts","        case cherry","        case fudge","    }","","    typealias RawValue = Int","    var rawValue: RawValue","    init() { self.rawValue = 0 }","    init(rawValue: RawValue) { self.rawValue = rawValue }","    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)","    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)","    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)","}","extension SundaeToppings: OptionSet { }"]},{"inlineContent":[{"type":"text","text":"private 열거형 뒤에 모든 코드는 "},{"type":"codeVoice","code":"@OptionSet"},{"type":"text","text":" 매크로에서 가져옵니다. static 변수를 생성하기 위해 매크로를 사용하는 "},{"code":"SundaeToppings","type":"codeVoice"},{"text":" 의 버전은 이전의 수동으로 된 코드보다 더 읽기 쉽고 유지보수 하기도 더 쉽습니다.","type":"text"}],"type":"paragraph"},{"anchor":"%EB%A7%A4%ED%81%AC%EB%A1%9C-%EC%84%A0%EC%96%B8-Macro-Declarations","type":"heading","level":2,"text":"매크로 선언 (Macro Declarations)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"대부분 Swift 코드에서 함수 또는 타입과 같은 기호를 구현할 때, 별도의 선언이 없습니다. 그러나, 매크로의 경우 선언과 구현은 분리되어 있습니다. 매크로의 선언은 매크로의 이름, 매크로가 가지는 파라미터, 어디서 사용될 수 있는지, 어떤 코드를 생성하는지가 포함됩니다. 매크로의 구현은 Swift 코드를 생성하여 매크로를 확장하는 코드를 포함합니다."}]},{"type":"paragraph","inlineContent":[{"text":"매크로는 ","type":"text"},{"type":"codeVoice","code":"macro"},{"text":" 키워드로 선언합니다. 예를 들어, 이전 예시에서 사용된 ","type":"text"},{"type":"codeVoice","code":"@OptionSet"},{"type":"text","text":" 매크로에 대한 선언의 일부분입니다:"}]},{"code":["public macro OptionSet<RawType>() =","        #externalMacro(module: \"SwiftMacros\", type: \"OptionSetMacro\")"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"첫번째 줄은 매크로의 이름과 매크로의 인자를 지정합니다 - 이름은 ","type":"text"},{"type":"codeVoice","code":"OptionSet"},{"text":" 이고 인자는 가지고 있지 않습니다. 두번째 줄은 Swift 표준 라이브러리에 ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/externalmacro(module:type:)","type":"reference","isActive":true},{"text":" 매크로를 사용하여 Swift 에 매크로의 구현 위치를 알려줍니다. 이 경우에 ","type":"text"},{"type":"codeVoice","code":"SwiftMacros"},{"text":" 모듈은 ","type":"text"},{"type":"codeVoice","code":"@OptionSet"},{"type":"text","text":" 매크로를 구현하는 "},{"code":"OptionSetMacro","type":"codeVoice"},{"text":" 를 포함합니다.","type":"text"}]},{"inlineContent":[{"code":"OptionSet","type":"codeVoice"},{"text":" 은 첨부 매크로이므로, 매크로의 이름은 구조체와 클래스 이름처럼 대문자 카멜 케이스로 사용합니다. 독립 매크로는 변수와 함수 이름처럼 소문자 카멜 케이스로 이름을 가집니다.","type":"text"}],"type":"paragraph"},{"name":"Note","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"text":"매크로는 항상 ","type":"text"},{"code":"public","type":"codeVoice"},{"type":"text","text":" 으로 선언됩니다. 매크로를 선언하는 코드는 매크로를 사용하는 코드의 모듈과 다르므로, public 이 아닌 매크로는 적용할 수 없습니다."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"매크로 선언은 매크로가 호출될 수 있는 코드의 위치와 매크로가 생성할 수 있는 코드의 종류인 매크로의 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"역할 (role)"}]},{"text":" 을 정의합니다. 모든 매크로는 하나 이상의 역할을 가지고 있고 매크로 선언의 앞에 속성의 부분으로 작성합니다. 다음은 ","type":"text"},{"type":"codeVoice","code":"@OptionSet"},{"type":"text","text":" 에 대한 역할의 속성을 포함한 선언의 일부분을 나타냅니다:"}]},{"syntax":"swift","code":["@attached(member)","@attached(extension, conformances: OptionSet)","public macro OptionSet<RawType>() =","        #externalMacro(module: \"SwiftMacros\", type: \"OptionSetMacro\")"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"code":"@attached","type":"codeVoice"},{"text":" 속성은 각 매크로 역할에 대해 한번씩 선언에서 두번 나타납니다. 첫번째는 ","type":"text"},{"type":"codeVoice","code":"@attached(member)"},{"text":" 를 사용하고 매크로가 적용된 타입에 새로운 멤버를 추가한다고 나타냅니다. ","type":"text"},{"type":"codeVoice","code":"@OptionSet"},{"type":"text","text":" 매크로는 "},{"type":"codeVoice","code":"OptionSet"},{"text":" 프로토콜에 의해 요구되는 ","type":"text"},{"code":"init(rawValue:)","type":"codeVoice"},{"type":"text","text":" 이니셜라이저과 멤버를 추가합니다."},{"text":" ","type":"text"},{"type":"text","text":"두번째는 "},{"type":"codeVoice","code":"@attached(extension, conformances: OptionSet)"},{"type":"text","text":" 를 사용하고 "},{"type":"codeVoice","code":"@OptionSet"},{"text":" 이 ","type":"text"},{"code":"OptionSet","type":"codeVoice"},{"type":"text","text":" 프로토콜의 준수성을 추가한다고 나타냅니다."},{"type":"text","text":" "},{"type":"codeVoice","code":"@OptionSet"},{"type":"text","text":" 매크로는 매크로를 적용한 타입을 확장하여 "},{"code":"OptionSet","type":"codeVoice"},{"type":"text","text":" 프로토콜의 준수성을 추가합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"독립 매크로에 대해 매크로의 역할을 지정하기 위해 "},{"code":"@freestanding","type":"codeVoice"},{"type":"text","text":" 속성을 작성합니다:"}]},{"type":"codeListing","syntax":"swift","code":["@freestanding(expression)","public macro line<T: ExpressibleByIntegerLiteral>() -> T =","        \/* ... location of the macro implementation... *\/"]},{"inlineContent":[{"text":"위에 ","type":"text"},{"code":"#line","type":"codeVoice"},{"text":" 매크로는 ","type":"text"},{"code":"expression","type":"codeVoice"},{"type":"text","text":" 역할을 가집니다. 매크로 표현식은 값을 생성하거나 컴파일 때 경고를 생성하듯이 어떠한 동작을 수행합니다."}],"type":"paragraph"},{"inlineContent":[{"text":"매크로의 역할 외에도 매크로의 선언은 매크로가 생성하는 기호의 이름에 대한 정보를 제공합니다. 매크로 선언이 이름을 제공하면 해당 이름을 사용하는 선언만 생성하므로 생성된 코드는 이해하고 디버그 하는데 도움을 줍니다. 다음은 ","type":"text"},{"code":"@OptionSet","type":"codeVoice"},{"type":"text","text":" 선언의 전체입니다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@attached(member, names: named(RawValue), named(rawValue),","        named(`init`), arbitrary)","@attached(extension, conformances: OptionSet)","public macro OptionSet<RawType>() =","        #externalMacro(module: \"SwiftMacros\", type: \"OptionSetMacro\")"]},{"inlineContent":[{"type":"text","text":"위의 선언에서 "},{"type":"codeVoice","code":"@attached(member)"},{"text":" 매크로는 ","type":"text"},{"code":"@OptionSet","type":"codeVoice"},{"text":" 매크로가 생성하는 각 기호에 대해 ","type":"text"},{"type":"codeVoice","code":"names:"},{"type":"text","text":" 레이블 뒤에 인자로 포함합니다. 매크로는 "},{"code":"RawValue","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"rawValue"},{"type":"text","text":", 그리고 "},{"type":"codeVoice","code":"init"},{"type":"text","text":" 의 이름인 기호에 대한 선언을 추가합니다 - 이러한 이름은 미리 알고 있기 때문에, 명시적으로 매크로 선언에 나열합니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"매크로 선언은 매크로를 사용할 때까지 알 수 없는 이름의 선언을 생성하기위해 이름의 뒤에 "},{"code":"arbitrary","type":"codeVoice"},{"text":" 도 포함합니다. 예를 들어, ","type":"text"},{"type":"codeVoice","code":"@OptionSet"},{"text":" 매크로가 위에 ","type":"text"},{"type":"codeVoice","code":"SundaeToppings"},{"text":" 에 적용하면, 열거형 케이스 인 ","type":"text"},{"code":"nuts","type":"codeVoice"},{"text":", ","type":"text"},{"code":"cherry","type":"codeVoice"},{"type":"text","text":", 그리고 "},{"type":"codeVoice","code":"fudge"},{"text":" 에 해당하는 타입 프로퍼티를 생성합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"매크로 역할의 종류와 더 자세한 내용은 ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes"},{"text":" 에 ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#attached","type":"reference"},{"text":" 와 ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#freestanding"},{"text":" 을 참고바랍니다.","type":"text"}]},{"level":2,"type":"heading","anchor":"%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%99%95%EC%9E%A5-Macro-Expansion","text":"매크로 확장 (Macro Expansion)"},{"type":"paragraph","inlineContent":[{"text":"매크로를 사용하는 Swift 코드를 빌드할 때 컴파일러는 매크로의 구현을 확장하기 위해 호출합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"macro-expansion-full","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"특히, Swift 는 아래와 같은 방식으로 매크로를 확장합니다:"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"컴파일러는 코드를 읽고 구문의 메모리 표현을 생성합니다."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"컴파일러는 메모리 표현의 일부분을 매크로 구현에 전송하여 매크로를 확장합니다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"컴파일러는 확장된 형태로 매크로 호출을 대체합니다."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"컴파일러는 확장된 소스 코드를 사용하여 완료될 때까지 계속 진행합니다."}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"특정 단계를 진행하려면, 다음을 참고 바랍니다:"}]},{"code":["let magicNumber = #fourCharacterCode(\"ABCD\")"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"#fourCharacterCode"},{"type":"text","text":" 매크로는 4글자의 문자열을 가지고 문자열의 ASCII 값에 해당하는 부호 없는 32비트 정수를 반환합니다. 일부 파일 형식은 압축되어 있지만 디버거에서 읽을 수 있기 때문에 데이터를 식별하기 위해 정수를 사용합니다. 아래 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Macros#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EA%B5%AC%ED%98%84-Implementing-a-Macro","isActive":true,"type":"reference"},{"type":"text","text":" 섹션에서는 이러한 매크로를 어떻게 구현하는지 보여줍니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 코드에서 매크로를 확장하기 위해, 컴파일러는 Swift 파일을 읽고 "},{"inlineContent":[{"text":"추상 구문 트리 (abstract syntax tree)","type":"text"}],"type":"emphasis"},{"text":" 또는 AST 라고 알려진 해당 코드의 메모리 표현을 생성합니다. AST 는 컴파일러나 매크로 구현과 같이 해당 구조와 상호작용하는 코드를 더 쉽게 작성하기 위해 코드의 구조를 명시적으로 만듭니다. 다음은 일부 상세정보를 단순화한 위 코드에 대한 AST 표현입니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"macro-ast-original"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 다이어그램은 이 코드의 구조가 메모리에서 어떻게 표현되는지 보여줍니다. AST 에서 각 요소는 소스코드의 일부분에 해당합니다. “상수 선언 (Constant declaration)” AST 요소는 상수 선언의 두 부분을 표현하는 두 개의 하위 요소를 가지고 있습니다: 두 부분은 상수의 이름과 상수의 값입니다. “매크로 호출 (Macro call)” 요소는 매크로의 이름과 매크로에 전달되는 인자의 목록을 표현하는 하위 요소들을 가지고 있습니다."}]},{"type":"paragraph","inlineContent":[{"text":"이 AST 의 구성의 부분으로, 컴파일러는 소스코드가 Swift 에 유효한지 확인합니다. 예를 들어, ","type":"text"},{"type":"codeVoice","code":"#fourCharacterCode"},{"type":"text","text":" 는 문자열이어야 한다는 하나의 인자를 가집니다. 정수 인자를 전달하거나 문자열 리터럴 끝에 쌍따옴표 ("},{"type":"codeVoice","code":"\""},{"text":") 를 빼먹으면, 오류가 발생합니다.","type":"text"}]},{"inlineContent":[{"text":"컴파일러는 매크로를 호출하는 위치를 코드에서 찾고, 해당 매크로를 구현한 외부 바이너리를 로드합니다. 각 매크로 호출에 대해 컴파일러는 AST 의 부분을 매크로의 구현에 전달합니다. 다음은 AST 의 해당 부분을 표현합니다:","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"macro-ast-input"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#fourCharacterCode"},{"type":"text","text":" 매크로의 구현은 매크로를 확장할 때 입력으로 이 부분의 AST 를 읽습니다. 매크로의 구현은 입력으로 받은 AST 에서만 동작합니다. 이 의미는 매크로는 앞, 뒤에 오는 코드에 관계없이 항상 같은 방식으로 확장합니다. 이 제한은 Swift 가 변경되지 않은 매크로 확장을 피할 수 있으므로, 매크로 확장을 더 쉽게 이해하도록 돕고, 코드 빌드 속도에 도움을 줍니다. Swift 는 매크로를 구현한 코드를 제한하여 매크로 작성자가 실수로 다른 입력을 읽는 것을 방지합니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"매크로 구현에 전달된 AST 는 매크로를 표현하는 AST 요소만 포함하고 앞 또는 뒤에 오는 코드를 포함하지 않습니다."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"매크로 구현은 파일 시스템 또는 네트워크 접근을 방지하는 샌드박스 환경 (sandboxed environment) 에서 실행됩니다."}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이러한 안전장치 외에도, 매크로의 작성자는 매크로의 입력 외에 항목을 읽거나 수정하지 않을 책임이 있습니다. 예를 들어, 매크로의 확장은 현재시간에 의존하지 않아야 합니다."}]},{"type":"paragraph","inlineContent":[{"code":"#fourCharacterCode","type":"codeVoice"},{"text":" 의 구현은 확장된 코드를 포함하는 새로운 AST 를 생성합니다. 다음은 코드가 컴파일러에 무엇을 반환하는지 나타냅니다:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"macro-ast-output"}]},{"inlineContent":[{"type":"text","text":"컴파일러가 이 확장을 받으면, 매크로 호출을 포함하는 AST 요소를 매크로의 확장이 포함된 요소로 대체합니다. 매크로 확장 후에, 컴파일러는 프로그램이 여전히 Swift 에 유효하고 모든 타입이 올바른지 다시 확인합니다. 그러면 컴파일 될 수 있는 최종 AST 가 생성됩니다."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"macro-ast-result"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This AST corresponds to Swift code like this:"}]},{"code":["let magicNumber = 1145258561 as UInt32"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"이 예시에서, 입력 소스코드는 하나의 매크로만 가지지만, 실제 프로그램에서는 동일한 매크로의 여러 인스턴스와 다른 매크로에 대한 여러 호출이 있을 수 있습니다. 컴파일러는 한 번에 하나씩 매크로를 확장합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"하나의 매크로가 다른 매크로 안에서 나타나면, 외부 매크로가 먼저 확장됩니다 - 이렇게 되면 확장되기 전에 외부 매크로는 내부 매크로를 수정할 수 있습니다."}]},{"type":"heading","level":2,"text":"매크로 구현 (Implementing a Macro)","anchor":"%EB%A7%A4%ED%81%AC%EB%A1%9C-%EA%B5%AC%ED%98%84-Implementing-a-Macro"},{"type":"paragraph","inlineContent":[{"type":"text","text":"매크로를 구현하기 위해, 두 개의 구성요소를 만듭니다: 매크로 확장을 수행하는 타입과 API 로 노출하도록 매크로를 선언한 라이브러리 입니다. 매크로 구현은 매크로의 클라이언트 빌드의 부분으로 수행되기 때문에, 매크로와 해당 클라이언트를 함께 개발하는 경우에도 이러한 부분은 매크로를 사용하는 코드와 별개로 빌드됩니다."}]},{"type":"paragraph","inlineContent":[{"text":"Swift Package Manager 를 사용하여 새로운 매크로를 생성하기 위해, ","type":"text"},{"type":"codeVoice","code":"swift package init --type macro"},{"type":"text","text":" 를 수행합니다 - 이것은 매크로 구현과 선언에 대한 템플릿을 포함하여 몇 개의 파일을 생성합니다."}]},{"inlineContent":[{"type":"text","text":"기존 프로젝트에 매크로를 추가하기 위해,"},{"type":"text","text":" "},{"text":"다음과 같이 ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"type":"text","text":" 파일에 처음을 수정합니다:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"swift-tools-version"},{"text":" 에 Swift tools 버전을 5.9 이상으로 지정합니다.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"CompilerPluginSupport","type":"codeVoice"},{"text":" 모듈을 가져옵니다.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"platforms"},{"text":" 목록에 최소 배포 타겟으로 macOS 10.15 를 포함합니다.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"아래의 코드는 ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"text":" 파일의 예시를 보여줍니다.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ swift-tools-version: 5.9","","import PackageDescription","import CompilerPluginSupport","","let package = Package(","    name: \"MyPackage\",","    platforms: [ .iOS(.v17), .macOS(.v13)],","    \/\/ ...",")"]},{"inlineContent":[{"type":"text","text":"다음으로 기존 "},{"type":"codeVoice","code":"Package.swift"},{"type":"text","text":" 파일에"},{"type":"text","text":" "},{"type":"text","text":"매크로 구현에 대한 타겟과"},{"type":"text","text":" "},{"type":"text","text":"매크로 라이브러리에 대한 타겟을 추가합니다."},{"text":" ","type":"text"},{"text":"예를 들어,","type":"text"},{"type":"text","text":" "},{"text":"해당 프로젝트와 일치하는 이름으로 변경하여","type":"text"},{"type":"text","text":" "},{"type":"text","text":"다음과 같이 추가할 수 있습니다:"}],"type":"paragraph"},{"code":["targets: [","    \/\/ Macro implementation that performs the source transformations.","    .macro(","        name: \"MyProjectMacros\",","        dependencies: [","            .product(name: \"SwiftSyntaxMacros\", package: \"swift-syntax\"),","            .product(name: \"SwiftCompilerPlugin\", package: \"swift-syntax\")","        ]","    ),","","    \/\/ Library that exposes a macro as part of its API.","    .target(name: \"MyProject\", dependencies: [\"MyProjectMacros\"]),","]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위 코드는 두 개의 타겟을 정의합니다: ","type":"text"},{"type":"codeVoice","code":"MyProjectMacros"},{"text":" 는 매크로의 구현을 포함하고, ","type":"text"},{"type":"codeVoice","code":"MyProject"},{"text":" 는 해당 매크로를 사용가능하도록 만듭니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"매크로의 구현은 AST 를 사용하여 구조화된 방식으로 Swift 코드와 상호작용하기 위해 "},{"isActive":true,"identifier":"http:\/\/github.com\/apple\/swift-syntax\/","type":"reference"},{"type":"text","text":" 모듈을 사용합니다. Swift Package Manager 로 새로운 매크로 패키지를 생성하면, 생성된 "},{"type":"codeVoice","code":"Package.swift"},{"text":" 파일은 자동으로 SwiftSyntax 에 대한 의존성을 추가합니다. 기존 프로젝트에 매크로를 추가하면, ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"type":"text","text":" 파일에 SwiftSyntax 에 대한 의존성을 추가합니다:"}],"type":"paragraph"},{"code":["dependencies: [","    .package(url: \"https:\/\/github.com\/apple\/swift-syntax\", from: \"509.0.0\")","],"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"위 코드에서 "},{"code":"some-tag","type":"codeVoice"},{"type":"text","text":" 에 대한 표시자를 사용할 SwiftSyntax 의 버전에 대한 Git 태그로 대체합니다."}],"type":"paragraph"},{"inlineContent":[{"text":"매크로의 역할에 따라, 매크로 구현이 준수하는 SwiftSystem 의 프로토콜이 있습니다. 예를 들어, 이전 섹선에 ","type":"text"},{"code":"#fourCharacterCode","type":"codeVoice"},{"text":" 를 생각해 봅시다. 다음은 해당 매크로를 구현하는 구조체입니다:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["import SwiftSyntax","import SwiftSyntaxMacros","","public struct FourCharacterCode: ExpressionMacro {","    public static func expansion(","        of node: some FreestandingMacroExpansionSyntax,","        in context: some MacroExpansionContext","    ) throws -> ExprSyntax {","        guard let argument = node.argumentList.first?.expression,","              let segments = argument.as(StringLiteralExprSyntax.self)?.segments,","              segments.count == 1,","              case .stringSegment(let literalSegment)? = segments.first","        else {","            throw CustomError.message(\"Need a static string\")","        }","","        let string = literalSegment.content.text","        guard let result = fourCharacterCode(for: string) else {","            throw CustomError.message(\"Invalid four-character code\")","        }","","        return \"\\(raw: result) as UInt32\"","    }","}","","private func fourCharacterCode(for characters: String) -> UInt32? {","    guard characters.count == 4 else { return nil }","","    var result: UInt32 = 0","    for character in characters {","        result = result << 8","        guard let asciiValue = character.asciiValue else { return nil }","        result += UInt32(asciiValue)","    }","    return result","}","enum CustomError: Error { case message(String) }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 매크로를 기존에 Swift Package Manager 프로젝트에 추가하는 경우에,"},{"type":"text","text":" "},{"type":"text","text":"매크로 타겟에 대한 시작지점으로 역할하고"},{"type":"text","text":" "},{"text":"타겟을 정의하는 매크로의 목록의 타입을 추가합니다:","type":"text"}]},{"type":"codeListing","code":["import SwiftCompilerPlugin","","@main","struct MyProjectMacros: CompilerPlugin {","    var providingMacros: [Macro.Type] = [FourCharacterCode.self]","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"code":"#fourCharacterCode","type":"codeVoice"},{"text":" 매크로는 표현식을 생성하는 독립 매크로이므로, 구현한 ","type":"text"},{"type":"codeVoice","code":"FourCharacterCode"},{"type":"text","text":" 타입은 "},{"type":"codeVoice","code":"ExpressionMacro"},{"type":"text","text":" 프로토콜을 준수합니다. "},{"type":"codeVoice","code":"ExpressionMacro"},{"text":" 프로토콜은 AST 를 확장하는 ","type":"text"},{"code":"expansion(of:in:)","type":"codeVoice"},{"type":"text","text":" 메서드 인 하나의 요구사항을 가집니다. 매크로 역할과 해당 SwiftSystem 프로토콜의 목록은 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes"},{"type":"text","text":" 에 "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#attached"},{"text":" 와 ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#freestanding","isActive":true},{"type":"text","text":" 을 참고바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#fourCharacterCode"},{"type":"text","text":" 매크로를 확장하기 위해, Swift 는 이 매크로를 사용하는 코드에 대한 AST 를 매크로 구현을 포함하는 라이브러리로 보냅니다. 라이브러리에서 Swift 는 "},{"code":"FourCharacterCode.expansion(of:in:)","type":"codeVoice"},{"text":" 을 호출하고, AST 와 컨텍스트를 인자로 메서드에 전달합니다. ","type":"text"},{"code":"expansion(of:in:)","type":"codeVoice"},{"text":" 의 구현은 ","type":"text"},{"type":"codeVoice","code":"#fourCharacterCode"},{"type":"text","text":" 에 인자로 전달된 문자열을 찾고, 부호 없는 32-bit 정수 리터럴 값으로 계산합니다."}]},{"inlineContent":[{"text":"위 예시에서, 첫번재 ","type":"text"},{"type":"codeVoice","code":"guard"},{"text":" 블럭은 AST 에서 문자열 리터럴을 추출하고, ","type":"text"},{"code":"literalSegment","type":"codeVoice"},{"text":" 에 해당 AST 요소를 할당합니다. 두번째 ","type":"text"},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 블럭에서 private "},{"code":"fourCharacterCode(for:)","type":"codeVoice"},{"type":"text","text":" 함수를 호출합니다. 해당 블럭들은 매크로가 올바르게 사용되지 않으면 오류가 발생합니다 - 오류 메세지는 잘못된 호출 부분에서 컴파일 오류가 됩니다. 예를 들어, "},{"code":"#fourCharacterCode(\"AB\" + \"CD\")","type":"codeVoice"},{"type":"text","text":" 로 매크로를 호출하면 컴파일러는 “Need a static string.” 이라는 오류가 발생합니다."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"expansion(of:in:)"},{"type":"text","text":" 매크로는 AST 에서 표현식을 표현하는 SwiftSyntax 의 타입인 "},{"code":"ExprSyntax","type":"codeVoice"},{"type":"text","text":" 의 인스턴스를 반환합니다. 이 타입은 "},{"code":"StringLiteralConvertible","type":"codeVoice"},{"text":" 프로토콜을 준수하기 때문에, 매크로 구현은 결과를 생성하기 위해 가벼운 구문 (lightweight syntax) 으로 문자열 리터럴을 사용합니다. 매크로 구현에서 반환하는 모든 SwiftSyntax 타입은 ","type":"text"},{"code":"StringLiteralConvertible","type":"codeVoice"},{"type":"text","text":" 을 준수하므로, 모든 종류의 매크로를 구현할 때 이 접근방식을 사용할 수 있습니다."}],"type":"paragraph"},{"text":"매크로 개발과 디버깅 (Developing and Debugging Macros)","type":"heading","level":2,"anchor":"%EB%A7%A4%ED%81%AC%EB%A1%9C-%EA%B0%9C%EB%B0%9C%EA%B3%BC-%EB%94%94%EB%B2%84%EA%B9%85-Developing-and-Debugging-Macros"},{"inlineContent":[{"text":"매크로는 테스트를 사용하는 개발에 적합합니다: 외부상태에 의존하지 않고 외부상태에 변경없이 하나의 AST 를 다른 AST 로 변환합니다. 추가로, 테스트에 입력설정을 단순화하는 문자열 리터럴에서 구문 노드를 생성할 수 있습니다. 예상되는 값과 비교하기 위해 문자열을 가져오는 AST 의 ","type":"text"},{"type":"codeVoice","code":"description"},{"text":" 프로퍼티를 읽을 수도 있습니다. 예를 들어, 다음은 이전 섹션에 ","type":"text"},{"type":"codeVoice","code":"#fourCharacterCode"},{"type":"text","text":" 매크로의 테스트 입니다:"}],"type":"paragraph"},{"syntax":"swift","code":["let source: SourceFileSyntax =","    \"\"\"","    let abcd = #fourCharacterCode(\"ABCD\")","    \"\"\"","","let file = BasicMacroExpansionContext.KnownSourceFile(","    moduleName: \"MyModule\",","    fullFilePath: \"test.swift\"",")","","let context = BasicMacroExpansionContext(sourceFiles: [source: file])","","let transformedSF = source.expand(","    macros:[\"fourCharacterCode\": FourCharacterCode.self],","    in: context",")","","let expectedDescription =","    \"\"\"","    let abcd = 1145258561 as UInt32","    \"\"\"","","precondition(transformedSF.description == expectedDescription)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 예시는 사전 조건을 사용하여 매크로를 테스트 하지만, 테스트 프레임워크를 사용할 수도 있습니다."}]}],"kind":"content"}],"metadata":{"title":"매크로 (Macros)"},"references":{"http://github.com/apple/swift-syntax/":{"identifier":"http:\/\/github.com\/apple\/swift-syntax\/","titleInlineContent":[{"text":"SwiftSyntax","type":"text"}],"type":"link","url":"http:\/\/github.com\/apple\/swift-syntax\/","title":"SwiftSyntax"},"https://developer.apple.com/documentation/swift/externalmacro(module:type:)":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/externalmacro(module:type:)","titleInlineContent":[{"type":"codeVoice","code":"externalMacro(module:type:)"}],"type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/externalmacro(module:type:)","title":"externalMacro(module:type:)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Attributes#attached":{"url":"\/documentation\/the-swift-programming-language-korean\/attributes#attached","title":"attached","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#attached","kind":"section","type":"topic"},"macro-ast-output":{"alt":"A tree diagram with the integer literal 1145258561 of type UInt32.","variants":[{"url":"\/images\/org.swift.tsplk\/macro-ast-output@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tsplk\/macro-ast-output~dark@2x.png"}],"identifier":"macro-ast-output","type":"image"},"macro-ast-result":{"alt":"A tree diagram, with a constant as the root element.  The constant has a name, magic number, and a value.  The constant’s value is the integer literal 1145258561 of type UInt32.","variants":[{"url":"\/images\/org.swift.tsplk\/macro-ast-result@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tsplk\/macro-ast-result~dark@2x.png"}],"identifier":"macro-ast-result","type":"image"},"https://developer.apple.com/documentation/swift/function()":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/function()","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/function()","type":"link","titleInlineContent":[{"type":"codeVoice","code":"function"}],"title":"function"},"macro-expansion":{"alt":"A diagram showing an overview of macro expansion.  On the left, a stylized representation of Swift code.  On the right, the same code with several lines added by the macro.","variants":[{"url":"\/images\/org.swift.tsplk\/macro-expansion@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tsplk\/macro-expansion~dark@2x.png"}],"identifier":"macro-expansion","type":"image"},"doc://org.swift.tsplk/documentation/TSPLK":{"kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/TSPLK","type":"topic","url":"\/documentation\/tsplk","abstract":[],"title":"The Swift Programming Language (6) (한국어)","role":"collection"},"macro-ast-original":{"alt":"A tree diagram, with a constant as the root element.  The constant has a name, magic number, and a value.  The constant’s value is a macro call.  The macro call has a name, fourCharacterCode, and arguments.  The argument is a string literal, ABCD.","variants":[{"url":"\/images\/org.swift.tsplk\/macro-ast-original@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tsplk\/macro-ast-original~dark@2x.png"}],"identifier":"macro-ast-original","type":"image"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Attributes":{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes","role":"article","type":"topic","kind":"article","title":"속성 (Attributes)","abstract":[{"text":"선언과 타입에 정보를 추가합니다.","type":"text"}],"url":"\/documentation\/the-swift-programming-language-korean\/attributes"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Attributes#freestanding":{"kind":"section","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#freestanding","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/attributes#freestanding","title":"freestanding"},"macro-ast-input":{"alt":"A tree diagram, with a macro call as the root element.  The macro call has a name, fourCharacterCode, and arguments.  The argument is a string literal, ABCD.","variants":[{"url":"\/images\/org.swift.tsplk\/macro-ast-input@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tsplk\/macro-ast-input~dark@2x.png"}],"identifier":"macro-ast-input","type":"image"},"https://developer.apple.com/documentation/swift/warning(_:)":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/warning(_:)","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/warning(_:)","type":"link","titleInlineContent":[{"type":"codeVoice","code":"warning(_:)"}],"title":"warning(_:)"},"https://developer.apple.com/documentation/swift/optionset":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/optionset","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/optionset","type":"link","titleInlineContent":[{"type":"codeVoice","code":"OptionSet"}],"title":"OptionSet"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Macros#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EA%B5%AC%ED%98%84-Implementing-a-Macro":{"kind":"section","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Macros#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EA%B5%AC%ED%98%84-Implementing-a-Macro","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/macros#%EB%A7%A4%ED%81%AC%EB%A1%9C-%EA%B5%AC%ED%98%84-Implementing-a-Macro","title":"매크로 구현 (Implementing a Macro)"},"macro-expansion-full":{"alt":"Diagram showing the four steps of expanding macros.  The input is Swift source code.  This becomes a tree, representing the code’s structure.  The macro implementation adds branches to the tree.  The result is Swift source with additional code.","variants":[{"url":"\/images\/org.swift.tsplk\/macro-expansion-full@2x.png","traits":["2x","light"]},{"traits":["2x","dark"],"url":"\/images\/org.swift.tsplk\/macro-expansion-full~dark@2x.png"}],"identifier":"macro-expansion-full","type":"image"}}}