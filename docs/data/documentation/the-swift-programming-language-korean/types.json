{"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/TSPLK"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Types"},"kind":"article","abstract":[{"text":"내장된 타입과 복합 타입을 사용합니다.","type":"text"}],"metadata":{"title":"타입 (Types)"},"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"text":"Swift 에서 명명된 타입과 복합 타입의 두가지 종류가 있습니다. ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"명명된 타입 (named type)"}]},{"type":"text","text":" 은 정의될 때 특정 이름을 부여할 수 있는 타입입니다. 명명된 타입은 클래스, 구조체, 열거형, 그리고 프로토콜을 포함합니다. 예를 들어 "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":" 라는 사용자 정의 클래스의 인스턴스는 "},{"code":"MyClass","type":"codeVoice"},{"type":"text","text":" 타입을 가집니다. 사용자 정의 명명된 타입 외에도 Swift 표준 라이브러리는 배열, 딕셔너리, 그리고 옵셔널 값을 나타내는 타입을 포함하여 일반적으로 사용되는 명명된 타입을 정의합니다."}]},{"type":"paragraph","inlineContent":[{"text":"데이터 타입 (Data types) 은 다른 언어에서 일반적으로 기본 또는 원시라고 간주됩니다 — 숫자, 문자, 그리고 문자열을 나타내는 타입 — Swift 표준 라이브러리에서는 구조체를 사용하여 정의되고 구현된 타입입니다. 명명된 타입이므로 필요에 따라 프로그램에 맞게 적절하게 동작을 ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions"},{"text":" 과 ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration"},{"type":"text","text":" 에서 설명된대로 확장 선언을 사용하여 확장할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"복합 타입 (compound type)"}],"type":"emphasis"},{"text":" 은 Swift 언어 자체에 정의된 이름이 없는 타입입니다. 복합 타입은 함수 타입과 튜플 타입 두가지가 있습니다. 복합 타입은 명명된 타입과 다른 복합 타입을 포함할 수 있습니다. 예를 들어 튜플 타입 ","type":"text"},{"type":"codeVoice","code":"(Int, (Int, Int))"},{"text":" 는 첫번째는 명명된 타입인 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":", 두번째는 다른 복합 타입 "},{"code":"(Int, Int)","type":"codeVoice"},{"type":"text","text":" 인 두개의 요소가 포함됩니다."}]},{"inlineContent":[{"text":"명명된 타입 또는 복합 타입을 묶을 소괄호를 넣을 수 있습니다. 그러나 타입을 묶은 소괄호는 아무런 영향을 주지 않습니다. 예를 들어 ","type":"text"},{"code":"(Int)","type":"codeVoice"},{"text":" 는 ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" 와 같습니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"이 챕터에서는 Swift 언어 자체에 정의된 타입과 Swift 의 타입 추론에 대해 설명합니다.","type":"text"}],"type":"paragraph"},{"name":"Grammar of a type","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"array-type"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-type"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"type-identifier"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-type","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-type"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"implicitly-unwrapped-optional-type","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-type"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"opaque-type","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"boxed-protocol-type"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"metatype-type","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"any-type","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"self-type","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"}],"type":"paragraph"}]},{"type":"heading","text":"타입 주석 (Type Annotation)","anchor":"타입-주석-Type-Annotation","level":2},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"타입 주석 (type annotation)","type":"text"}],"type":"emphasis"},{"text":" 은 변수 또는 표현식의 타입을 명시적으로 지정합니다. 타입 주석은 아래 예제에서 보여주듯이 콜론 (","type":"text"},{"type":"codeVoice","code":":"},{"text":") 으로 시작하고 타입으로 끝납니다:","type":"text"}]},{"code":["let someTuple: (Double, Double) = (3.14159, 2.71828)","func someFunction(a: Int) { \/* ... *\/ }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"첫번째 예제에서 표현식 ","type":"text"},{"code":"someTuple","type":"codeVoice"},{"text":" 은 튜플 타입 ","type":"text"},{"type":"codeVoice","code":"(Double, Double)"},{"text":" 을 갖도록 지정됩니다. 두번째 예제는 함수 ","type":"text"},{"type":"codeVoice","code":"someFunction"},{"type":"text","text":" 에 파라미터 "},{"type":"codeVoice","code":"a"},{"type":"text","text":" 는 타입 "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 를 갖도록 지정합니다."}]},{"inlineContent":[{"text":"타입 주석은 타입 앞에 타입 속성의 옵셔널 리스트을 포함할 수 있습니다.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"type-annotation"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"attributes"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]}],"style":"note","name":"Grammar of a type annotation","type":"aside"},{"anchor":"타입-식별자-Type-Identifier","type":"heading","level":2,"text":"타입 식별자 (Type Identifier)"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"타입 식별자 (type identifier)"}],"type":"emphasis"},{"type":"text","text":" 는 명명된 타입 또는 명명된 타입 또는 복합 타입의 타입 별칭 (type alias) 을 나타냅니다."}]},{"inlineContent":[{"text":"대부분의 경우 타입 식별자는 식별자로 같은 이름의 명명된 타입을 직접 참조합니다. 예를 들어 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 는 명명된 타입 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 직접 참조하는 타입 식별자이고 타입 식별자 "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"text":" 는 명명된 타입 ","type":"text"},{"code":"Dictionary<String, Int>","type":"codeVoice"},{"type":"text","text":" 를 직접 참조합니다."}],"type":"paragraph"},{"inlineContent":[{"text":"타입 식별자가 동일한 이름의 타입을 참조하지 않는 두가지 경우가 있습니다. 첫번째는 타입 식별자는 명명된 타입 또는 복합 타입의 타입 별칭을 나타냅니다. 예를 들어 아래 예제에서 타입 주석에서 ","type":"text"},{"type":"codeVoice","code":"Point"},{"text":" 의 사용은 튜플 타입 ","type":"text"},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" 를 나타냅니다."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["typealias Point = (Int, Int)","let origin: Point = (0, 0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두번째 경우 타입 식별자는 다른 모듈에서 선언되거나 다른 타입 내에 중첩된 명명된 타입을 참조하기 위해 점 ("},{"code":".","type":"codeVoice"},{"text":") 구문을 사용합니다. 예를 들어 다음 코드의 타입 식별자는 ","type":"text"},{"code":"ExampleModule","type":"codeVoice"},{"type":"text","text":" 모듈에 선언된 명명된 타입 "},{"code":"MyType","type":"codeVoice"},{"type":"text","text":" 을 참조합니다."}]},{"code":["var someValue: ExampleModule.MyType"],"type":"codeListing","syntax":"swift"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"type-identifier","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"type-name","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"generic-argument-clause","type":"text"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-name"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"generic-argument-clause","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-name","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]}],"type":"paragraph"}],"style":"note","name":"Grammar of a type identifier"},{"level":2,"type":"heading","anchor":"튜플-타입-Tuple-Type","text":"튜플 타입 (Tuple Type)"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"튜플 타입 (tuple type)"}]},{"type":"text","text":" 은 소괄호로 묶인 콤마로 구분된 타입의 리스트입니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"튜플 타입을 함수의 반환 타입으로 사용하여 함수가 여러값을 포함하는 단일 튜플을 반환하도록 할 수 있습니다. 튜플 타입의 요소에 이름을 지정하고 해당 이름을 사용하여 개별 요소의 값을 참조할 수도 있습니다. 요소 이름은 바로 뒤에 콜론 ("},{"type":"codeVoice","code":":"},{"type":"text","text":") 이 오는 식별자로 구성됩니다. 이러한 기능을 보여주는 예제는 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","isActive":true,"type":"reference"},{"type":"text","text":" 를 참고 바랍니다."}]},{"inlineContent":[{"text":"튜플 타입의 요소가 이름을 가지는 경우 이름은 타입의 부분입니다.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var someTuple = (top: 10, bottom: 12)  \/\/ someTuple is of type (top: Int, bottom: Int)","someTuple = (top: 4, bottom: 42) \/\/ OK: names match","someTuple = (9, 99)              \/\/ OK: names are inferred","someTuple = (left: 5, right: 5)  \/\/ Error: names don't match"]},{"type":"paragraph","inlineContent":[{"text":"모든 튜플 타입은 빈 튜플 타입 인 ","type":"text"},{"type":"codeVoice","code":"()"},{"type":"text","text":" 에 대한 타입 별칭인 "},{"code":"Void","type":"codeVoice"},{"type":"text","text":" 를 제외하고 두 개 이상의 타입을 포함합니다."}]},{"style":"note","type":"aside","name":"Grammar of a tuple type","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"text":"tuple-type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"tuple-type-element"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element-list"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"tuple-type-element-list"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-type-element","type":"text"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"text":"tuple-type-element","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"tuple-type-element-list","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-type-element","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"element-name","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"text":" | ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"element-name"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"}],"type":"paragraph"}]},{"level":2,"text":"함수 타입 (Function Type)","type":"heading","anchor":"함수-타입-Function-Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입 (function type) 은 함수, 메서드, 또는 클로저의 타입을 나타내고 화살표 ("},{"code":"->","type":"codeVoice"},{"type":"text","text":") 로 구분된 파라미터와 반환 타입으로 구성됩니다:"}]},{"code":["(<#parameter type#>) -> <#return type#>"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"파라미터 타입 (parameter type)","type":"text"}]},{"type":"text","text":" 은 콤마로 구분된 타입의 리스트입니다. "},{"inlineContent":[{"text":"반환 타입 (return type)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 은 튜플 타입일 수 있기 때문에 함수 타입은 여러값을 반환하는 함수와 메서드를 지원합니다."}]},{"type":"paragraph","inlineContent":[{"text":"함수 타입 ","type":"text"},{"type":"codeVoice","code":"() -> T"},{"type":"text","text":" (여기서 "},{"code":"T","type":"codeVoice"},{"type":"text","text":" 는 모든 타입) 의 파라미터는 "},{"type":"codeVoice","code":"autoclosure"},{"text":" 속성을 적용하여 호출 부분에서 암시적으로 클로저를 생성할 수 있습니다. 이것은 함수를 호출할 때 명시적으로 클로저를 작성할 필요없이 표현식의 평가를 연기하는 구문상 편리함을 제공합니다. 자동 클로저 함수 타입 파라미터의 예제는 ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures"},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입은 "},{"type":"emphasis","inlineContent":[{"text":"파라미터 타입","type":"text"}]},{"text":" 에 가변 파라미터 (variadic parameters) 를 가질 수 있습니다. 구문적으로 가변 파라미터는 ","type":"text"},{"code":"Int...","type":"codeVoice"},{"type":"text","text":" 와 같이 기본 타입 이름과 바로 뒤에 점 3개 ("},{"code":"...","type":"codeVoice"},{"text":") 로 구성됩니다. 가변 파라미터는 기본 타입 이름의 요소를 포함하는 배열로 처리됩니다. 예를 들어 가변 파라미터 ","type":"text"},{"code":"Int...","type":"codeVoice"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"[Int]"},{"text":" 로 처리됩니다. 가변 파라미터를 사용하는 예제는 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters","isActive":true,"type":"reference"},{"text":" 를 참고 바랍니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"in-out 파라미터 (in-out parameter) 를 지정하려면 ","type":"text"},{"type":"codeVoice","code":"inout"},{"type":"text","text":" 키워드를 파라미터 타입 앞에 붙여야 합니다. "},{"code":"inout","type":"codeVoice"},{"text":" 키워드로 가변 파라미터나 반환 타입으로 표시할 수 없습니다. In-out 파라미터는 ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters"},{"type":"text","text":" 에 설명되어 있습니다."}]},{"type":"paragraph","inlineContent":[{"text":"함수 타입에 파라미터가 하나만 가지고 있고 파라미터 타입이 튜플 타입인 경우 함수 타입을 작성할 때 튜플 타입을 괄호로 묶어야 합니다. 예를 들어 ","type":"text"},{"type":"codeVoice","code":"((Int, Int)) -> Void"},{"text":" 는 튜플 타입 ","type":"text"},{"code":"(Int, Int)","type":"codeVoice"},{"text":" 의 단일 파라미터를 가지고 값을 반환하지 않는 함수 타입입니다. 반대로 괄호가 없으면 ","type":"text"},{"type":"codeVoice","code":"(Int, Int) -> Void"},{"type":"text","text":" 는 두 개의 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 파라미터를 가지고 값을 반환하지 않는 함수 타입입니다. 마찬가지로 "},{"type":"codeVoice","code":"Void"},{"text":" 는 ","type":"text"},{"code":"()","type":"codeVoice"},{"text":" 에 대한 타입 별칭 이므로 함수 타입 ","type":"text"},{"type":"codeVoice","code":"(Void) -> Void"},{"type":"text","text":" 는 "},{"code":"(()) -> ()","type":"codeVoice"},{"type":"text","text":" 와 같습니다—빈 튜플인 단일 인수를 가지는 함수와 같습니다. 이 타입은 "},{"type":"codeVoice","code":"() -> ()"},{"type":"text","text":" 와 같지 않습니다 — 인수를 가지지 않는 함수입니다."}]},{"inlineContent":[{"type":"text","text":"함수와 메서드에 인수 이름은 해당 함수 타입의 일부가 아닙니다. 예를 들어:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func someFunction(left: Int, right: Int) {}","func anotherFunction(left: Int, right: Int) {}","func functionWithDifferentLabels(top: Int, bottom: Int) {}","","var f = someFunction \/\/ The type of f is (Int, Int) -> Void, not (left: Int, right: Int) -> Void.","f = anotherFunction              \/\/ OK","f = functionWithDifferentLabels  \/\/ OK","","func functionWithDifferentArgumentTypes(left: Int, right: String) {}","f = functionWithDifferentArgumentTypes     \/\/ Error","","func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}","f = functionWithDifferentNumberOfArguments \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"인수 라벨은 함수 타입의 일부분이 아니므로 함수 타입을 작성할 때 생략합니다."}]},{"syntax":"swift","code":["var operation: (lhs: Int, rhs: Int) -> Int     \/\/ Error","var operation: (_ lhs: Int, _ rhs: Int) -> Int \/\/ OK","var operation: (Int, Int) -> Int               \/\/ OK"],"type":"codeListing"},{"inlineContent":[{"text":"함수 타입에 하나 이상의 화살표 (","type":"text"},{"type":"codeVoice","code":"->"},{"type":"text","text":") 를 포함하는 경우 함수 타입은 오른쪽에서 왼쪽으로 그룹화 됩니다. 예를 들어 함수 타입 "},{"type":"codeVoice","code":"(Int) -> (Int) -> Int"},{"text":" 는 ","type":"text"},{"type":"codeVoice","code":"(Int) -> ((Int) -> Int)"},{"text":" 로 이해됩니다 — 이 함수는 ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" 를 가지며 ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 가지고 반환하는 다른 함수를 반환합니다."}],"type":"paragraph"},{"inlineContent":[{"text":"에러를 발생 시키거나 다시 발생 시킬 수 있는 함수에 대한 함수 타입은 ","type":"text"},{"type":"codeVoice","code":"throws"},{"text":" 키워드로 표시되어야 합니다. ","type":"text"},{"type":"codeVoice","code":"throws"},{"text":" 키워드는 함수 타입의 일부분이며 던지지 않는 함수 (nonthrowing functions) 는 던지는 함수 (throwing functions) 의 하위 타입 (subtypes) 입니다. 결과적으로 던지는 함수로 같은 위치에서 던지지 않는 함수를 사용할 수 있습니다. 던지는 함수와 던지지 않는 함수는 ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods"},{"text":" 와 ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods"},{"type":"text","text":" 에 설명되어 있습니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"비동기 함수에 대한 함수 타입은 "},{"code":"async","type":"codeVoice"},{"text":" 키워드로 표시되어야 합니다. ","type":"text"},{"code":"async","type":"codeVoice"},{"type":"text","text":" 키워드는 함수의 타입의 부분이며, 동기 함수는 비동기 함수의 하위 타입 (subtypes) 입니다. 결과적으로 비동기 함수와 같은 위치에서 동기 함수를 사용할 수 있습니다. 비동기 함수에 대한 더 자세한 설명은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods"},{"text":" 를 참고 바랍니다.","type":"text"}]},{"anchor":"비탈출-클로저에-대한-제한사항-Restrictions-for-Nonescaping-Closures","level":3,"type":"heading","text":"비탈출 클로저에 대한 제한사항 (Restrictions for Nonescaping Closures)"},{"type":"paragraph","inlineContent":[{"text":"비탈출 함수 (nonescaping function) 인 파라미터는 값이 탈출 될 수 있으므로 타입 ","type":"text"},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 의 프로퍼티, 변수, 또는 상수에 저장될 수 없습니다."}]},{"type":"paragraph","inlineContent":[{"text":"비탈출 함수 인 파라미터는 다른 비탈출 함수 파라미터 인수로 전달될 수 없습니다. 이 제한사항은 Swift 가 런타임이 아닌 컴파일 시 메모리에 접근 충돌에 대한 검사를 더 많이 수행하는데 도움이 됩니다. 예를 들어:","type":"text"}]},{"syntax":"swift","code":["let external: (() -> Void) -> Void = { _ in () }","func takesTwoFunctions(first: (() -> Void) -> Void, second: (() -> Void) -> Void) {","    first { first {} }       \/\/ Error","    second { second {}  }    \/\/ Error","","    first { second {} }      \/\/ Error","    second { first {} }      \/\/ Error","","    first { external {} }    \/\/ OK","    external { first {} }    \/\/ OK","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위의 코드에서 ","type":"text"},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"text":" 에 대한 두 파라미터는 모두 함수입니다. 두 파라미터 모두 ","type":"text"},{"type":"codeVoice","code":"@escaping"},{"text":" 으로 표시되지 않으므로 결과적으로 둘다 비탈출 입니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"위의 예제에서 “Error” 로 표시된 4개의 함수 호출은 컴파일러 에러를 일으킵니다. ","type":"text"},{"type":"codeVoice","code":"first"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"second"},{"text":" 파라미터는 비탈출 함수이므로 다른 비탈출 함수 파라미터 인수로 전달될 수 없습니다. 반대로 “OK” 로 표시된 2개의 함수 호출은 컴파일러 에러를 발생시키지 않습니다. 이 함수 호출은 ","type":"text"},{"type":"codeVoice","code":"external"},{"text":" 이 ","type":"text"},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"type":"text","text":" 의 파라미터 중 하나가 아니므로 제한사항에 위배되지 않습니다."}]},{"inlineContent":[{"type":"text","text":"제한사항을 피해야 하는 경우 파라미터 중 하나를 탈출로 표시하거나 "},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"type":"text","text":" 함수를 이용하여 탈출 함수로 비탈출 함수 파라미터 중 하나를 임시로 변경해야 합니다. 메모리에 충돌 접근을 피하는 것에 대한 자세한 내용은 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/MemorySafety","isActive":true},{"text":" 을 참고 바랍니다.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"function-type","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"attributes","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"function-type-argument-clause","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"code":"async","type":"codeVoice"}],"type":"strong"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"throws"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"->"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"function-type-argument-clause","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"function-type-argument-clause"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"function-type-argument-list"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"..."}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"function-type-argument-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"function-type-argument","type":"text"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"function-type-argument","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"function-type-argument-list","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"function-type-argument","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"parameter-modifier","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"argument-label","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"argument-label","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}]}],"name":"Grammar of a function type","style":"note","type":"aside"},{"anchor":"배열-타입-Array-Type","type":"heading","level":2,"text":"배열 타입 (Array Type)"},{"type":"paragraph","inlineContent":[{"text":"Swift 언어는 Swift 표준 라이브러리 ","type":"text"},{"type":"codeVoice","code":"Array<Element>"},{"text":" 타입에 대해 다음과 같은 구문을 제공합니다:","type":"text"}]},{"type":"codeListing","code":["[<#type#>]"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 표현으로 다음의 두 선언도 동일합니다:"}]},{"syntax":"swift","type":"codeListing","code":["let someArray: Array<String> = [\"Alex\", \"Brian\", \"Dave\"]","let someArray: [String] = [\"Alex\", \"Brian\", \"Dave\"]"]},{"inlineContent":[{"text":"두 경우 모두 상수 someArray 는 문자열의 배열로 선언됩니다. 배열의 요소는 대괄호에 유효한 인덱스 값을 지정하여 서브 스크립트를 통해 접근할 수 있습니다: ","type":"text"},{"type":"codeVoice","code":"someArray[0]"},{"text":" 는 ","type":"text"},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":" 인 인덱스 0번째 요소를 나타냅니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"대괄호 쌍을 중첩하여 다차원 배열을 만들 수 있습니다. 여기서 요소의 기본 타입 이름은 가장 안쪽 대괄호 쌍에 포함됩니다. 예를 들어 대괄호 3쌍을 이용하여 정수의 3차원 배열을 생성할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다차원 배열의 요소에 접근할 때 가장 왼쪽에 있는 서브 스크립트 인덱스는 배열의 가장 바깥 쪽에 있는 요소를 참조합니다. 오른쪽에 있는 다음 서브 스크립트 인덱스는 한 차원 더 들어가는 중첩된 배열의 요소를 참조합니다. 이것은 위의 예제에서 "},{"type":"codeVoice","code":"array3D[0]"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"[[1, 2], [3, 4]]"},{"text":" 를 참조하고 ","type":"text"},{"code":"array3D[0][1]","type":"codeVoice"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"[3, 4]"},{"type":"text","text":" 그리고 "},{"type":"codeVoice","code":"array3D[0][1][1]"},{"type":"text","text":" 은 값 4를 참조합니다."}]},{"inlineContent":[{"type":"text","text":"Swift 표준 라이브러리 "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" 타입에 대한 자세한 설명은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays"},{"text":" 을 참고 바랍니다.","type":"text"}],"type":"paragraph"},{"name":"Grammar of an array type","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"array-type","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"[","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"]","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}]},{"level":2,"type":"heading","anchor":"딕셔너리-타입-Dictionary-Type","text":"딕셔너리 타입 (Dictionary Type)"},{"type":"paragraph","inlineContent":[{"text":"Swift 언어는 Swift 표준 라이브러리 ","type":"text"},{"type":"codeVoice","code":"Dictionary<Key, Value>"},{"type":"text","text":" 타입에 대해 아래와 같은 구문을 제공합니다:"}]},{"type":"codeListing","syntax":"swift","code":["[<#key type#>: <#value type#>]"]},{"type":"paragraph","inlineContent":[{"text":"다른 표현으로 다음의 두 선언도 동일합니다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let someDictionary: [String: Int] = [\"Alex\": 31, \"Paul\": 39]","let someDictionary: Dictionary<String, Int> = [\"Alex\": 31, \"Paul\": 39]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 경우 모두 상수 "},{"code":"someDictionary","type":"codeVoice"},{"type":"text","text":" 는 키로 문자열과 값으로 정수를 가지는 딕셔너리가 선언됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"딕셔너리의 값은 대괄호에 해당 키를 지정하여 접근할 수 있습니다: "},{"type":"codeVoice","code":"someDictionary[\"Alex\"]"},{"text":" 는 키 ","type":"text"},{"code":"\"Alex\"","type":"codeVoice"},{"text":" 와 연관된 값을 참조합니다. 서브 스크립트는 딕셔너리의 값 타입의 옵셔널 값을 반환합니다. 지정한 키가 딕셔너리에 포함되지 않은 경우 서브 스크립트는 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" 을 반환합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"딕셔너리의 키 타입은 Swift 표준 라이브러리 "},{"code":"Hashable","type":"codeVoice"},{"text":" 프로토콜을 준수해야 합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Swift 표준 라이브러리 ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":" 타입의 자세한 설명은 ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries","isActive":true},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"aside","name":"Grammar of a dictionary type","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-type"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"["}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"]","type":"codeVoice"}]}]}]},{"level":2,"type":"heading","anchor":"옵셔널-타입-Optional-Type","text":"옵셔널 타입 (Optional Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 언어는 Swift 표준 라이브러리에 정의된 명명된 타입 "},{"code":"Optional<Wrapped>","type":"codeVoice"},{"text":" 에 대해 접미사 ","type":"text"},{"type":"codeVoice","code":"?"},{"text":" 구문을 정의합니다. 다른 표현으로 다음의 두 선언은 동일합니다:","type":"text"}]},{"syntax":"swift","code":["var optionalInteger: Int?","var optionalInteger: Optional<Int>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 경우 모두 변수 "},{"type":"codeVoice","code":"optionalInteger"},{"type":"text","text":" 는 옵셔널 정수의 타입을 가지도록 선언됩니다. 타입과 "},{"code":"?","type":"codeVoice"},{"type":"text","text":" 사이에는 공백이 없을 수도 있습니다."}]},{"inlineContent":[{"type":"text","text":"타입 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 는 존재하거나 존재하지 않을 수 있는 값을 나타내는데 "},{"type":"codeVoice","code":"none"},{"text":" 과 ","type":"text"},{"type":"codeVoice","code":"some(Wrapped)"},{"text":" 의 두가지 케이스가 있는 열거형입니다. 모든 타입은 명시적으로 선언되거나 옵셔널 타입으로 암시적으로 변환될 수 있습니다. 옵셔널 변수 또는 프로퍼티를 선언할 때 초기값을 제공하지 않으면 자동으로 ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 로 설정합니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"옵셔널 타입의 인스턴스는 값을 포함할 경우 아래에서 보듯이 접시마 연산자 "},{"code":"!","type":"codeVoice"},{"type":"text","text":" 를 사용하여 값에 접근할 수 있습니다:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["optionalInteger = 42","optionalInteger! \/\/ 42"]},{"type":"paragraph","inlineContent":[{"code":"nil","type":"codeVoice"},{"type":"text","text":" 의 값을 가지는 옵셔널을 언래핑 하기위해 "},{"code":"!","type":"codeVoice"},{"text":" 연산자를 사용하면 런타임 에러가 발생합니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"옵셔널 표현식에 대해 조건부 수행을 위해 옵셔널 체이닝과 옵셔널 바인딩을 사용할 수도 있습니다. 값이 "},{"code":"nil","type":"codeVoice"},{"text":" 인 경우에 작업은 더이상 수행되지 않으므로 런타임 에러가 발생하지 않습니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"더 자세한 정보와 옵셔널 타입 사용에 대한 예제를 보려면 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals","type":"reference","isActive":true},{"type":"text","text":" 을 참고 바랍니다."}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"optional-type"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"?"}]}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of an optional type"},{"text":"암시적으로 언래핑된 옵셔널 타입 (Implicitly Unwrapped Optional Type)","type":"heading","level":2,"anchor":"암시적으로-언래핑된-옵셔널-타입-Implicitly-Unwrapped-Optional-Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 언어는 옵셔널 타입에 접근할 때 자동으로 언래핑된 동작을 추가하기 위해 Swift 표준 라이브러리에 정의된 명명된 타입 "},{"code":"Optional<Wrapped>","type":"codeVoice"},{"type":"text","text":" 에 대한 접미사 "},{"code":"!","type":"codeVoice"},{"text":" 구문을 정의합니다. ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" 의 값을 가지는 옵셔널에 암시적 언래핑을 사용하려고 하면 런타임 에러가 발생합니다. 암시적 언래핑 동작을 제외하고 다음의 두 선언은 동일합니다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var implicitlyUnwrappedString: String!","var explicitlyUnwrappedString: Optional<String>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입과 "},{"type":"codeVoice","code":"!"},{"type":"text","text":" 사이에 공백이 포함되지 않을 수 있습니다."}]},{"inlineContent":[{"type":"text","text":"암시적 언래핑은 해당 타입을 포함하는 선언의 의미를 변경하기 때문에 튜플 타입 또는 딕셔너리 또는 배열의 요소 타입과 같이 제너릭 타입 내에 중첩된 옵셔널 타입은 암시적 언래핑으로 표시할 수 없습니다. 예를 들어:"}],"type":"paragraph"},{"syntax":"swift","code":["let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  \/\/ Error","let implicitlyUnwrappedTuple: (Int, Int)!             \/\/ OK","","let arrayOfImplicitlyUnwrappedElements: [Int!]        \/\/ Error","let implicitlyUnwrappedArray: [Int]!                  \/\/ OK"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널은 옵셔널 값과 동일한 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 타입을 가지므로 옵셔널을 사용할 수 있는 코드에서 동일한 위치에서 암시적으로 언래핑된 옵셔널을 사용할 수 있습니다. 예를 들어 옵셔널의 변수, 상수, 그리고 프로퍼티에 암시적으로 언래핑된 옵셔널의 값을 할당할 수 있고 그 반대도 가능합니다."}]},{"type":"paragraph","inlineContent":[{"text":"옵셔널과 마찬가지로 암시적으로 언래핑된 옵셔널 변수 또는 프로퍼티를 선언할 때 초기값을 제공하지 않으면 자동으로 ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":" 을 기본값으로 설정합니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널 표현식에 조건부로 동작을 수행하려면 옵셔널 체이닝을 사용합니다. 값이 "},{"type":"codeVoice","code":"nil"},{"text":" 이라면 더이상 작업이 수행되지 않으며 런타임 에러가 발생하지 않습니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널 타입에 대한 자세한 정보는 "},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals","isActive":true,"type":"reference"},{"type":"text","text":" 을 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"text":"implicitly-unwrapped-optional-type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"code":"!","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}],"name":"Grammar of an implicitly unwrapped optional type","type":"aside"},{"text":"프로토콜 혼합 타입 (Protocol Composition Type)","type":"heading","level":2,"anchor":"프로토콜-혼합-타입-Protocol-Composition-Type"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"프로토콜 혼합 타입 (protocol composition type)"}]},{"text":" 은 지정된 프로토콜의 리스트에서 각 프로토콜을 준수하는 타입 또는 주어진 클래스의 하위 클래스와 지정된 프로토콜의 리스트애서 각 프로토콜을 준수하는 타입을 정의합니다. 프로토콜 혼합 타입은 타입 주석, 제너릭 파라미터 절, 그리고 제너릭 ","type":"text"},{"code":"where","type":"codeVoice"},{"type":"text","text":" 절을 지정할 때만 사용할 수 있습니다."}]},{"inlineContent":[{"text":"프로토콜 혼합 타입은 다음의 형식을 가집니다:","type":"text"}],"type":"paragraph"},{"code":["<#Protocol 1#> & <#Protocol 2#>"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 혼합 타입을 사용하면 타입이 준수하려는 각 프로토콜에서 상속되는 명명된 프로토콜을 새롭게 명시적으로 정의하지 않아도 타입이 여러 프로토콜의 요구사항을 준수하는 값을 지정할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"ProtocolA"},{"text":", ","type":"text"},{"type":"codeVoice","code":"ProtocolB"},{"text":", 그리고 ","type":"text"},{"code":"ProtocolC","type":"codeVoice"},{"type":"text","text":" 를 상속하는 새로운 프로토콜을 선언하는 대신 프로토콜 혼합 타입 "},{"code":"ProtocolA & ProtocolB & ProtocolC","type":"codeVoice"},{"type":"text","text":" 를 사용할 수 있습니다. 마찬가지로 "},{"code":"SuperClass","type":"codeVoice"},{"type":"text","text":" 의 하위 클래스와 "},{"code":"ProtocolA","type":"codeVoice"},{"type":"text","text":" 를 준수하는 새로운 프로토콜을 선언하는 대신에 "},{"code":"SuperClass & ProtocolA","type":"codeVoice"},{"text":" 를 사용할 수 있습니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 혼합 리스트에 각 항목은 다음 중 하나입니다; 이 리스트는 최대 하나의 클래스를 포함할 수 있습니다:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스의 이름"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"프로토콜의 이름"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"기본 타입이 프로토콜 구성 타입, 프로토콜, 또는 클래스 인 타입 별칭"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"프로토콜 혼합 타입이 타입 별칭을 포함할 때 동일한 프로토콜이 정의에 중복해서 나타날 수 있으며 중복은 무시됩니다. 예를 들어 아래 코드에서 ","type":"text"},{"code":"PQR","type":"codeVoice"},{"text":" 의 정의는 ","type":"text"},{"type":"codeVoice","code":"P & Q & R"},{"type":"text","text":" 과 동일합니다."}]},{"code":["typealias PQ = P & Q","typealias PQR = PQ & Q & R"],"type":"codeListing","syntax":"swift"},{"type":"aside","style":"note","name":"Grammar of a protocol composition type","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"protocol-composition-type"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"&"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"protocol-composition-continuation","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"protocol-composition-continuation"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"type-identifier","type":"text"}],"type":"emphasis"},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-type"}]}],"type":"paragraph"}]},{"anchor":"불투명한-타입-Opaque-Type","text":"불투명한 타입 (Opaque Type)","level":2,"type":"heading"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"불투명한 타입 (opaque type)"}]},{"type":"text","text":" 은 기본 타입 지정없이 프로토콜 또는 프로토콜 구성을 준수하는 타입을 정의합니다."}],"type":"paragraph"},{"inlineContent":[{"text":"불투명한 타입은 함수 또는 서브 스크립트의 반환타입 또는 프로퍼티의 타입으로 나타납니다. 불투명한 타입은 배열의 요소 타입 또는 옵셔널의 래핑된 타입과 같은 튜플 타입 또는 제너릭 타입의 부분으로 나타날 수 없습니다.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"불투명 타입은 다음의 형식을 가집니다:"}]},{"type":"codeListing","code":["some <#constraint#>"],"syntax":"swift"},{"inlineContent":[{"inlineContent":[{"text":"제약조건 (constraint)","type":"text"}],"type":"emphasis"},{"type":"text","text":" 은 클래스 타입, 프로토콜 타입, 프로토콜 구성 타입, 또는 "},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 입니다. 값은 나열된 프로토콜 또는 프로토콜 구성을 준수하는 타입의 인스턴스나 나열된 클래스를 상속하는 경우에만 불투명한 타입의 인스턴스로 사용될 수 있습니다. 불투명한 값과 상호작용하는 코드는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"제약조건 (constraint)"}]},{"text":" 에 의해 정의된 인터페이스의 일부의 방식으로만 값으로 사용할 수 있습니다.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"컴파일 시간에 타입이 불투명한 값은 특정한 구체적인 타입을 가지며, Swift 는 최적화를 위해 기본 타입을 사용할 수 있습니다. 그러나, 불투명한 타입은 기본 타입에 대한 정보를 교류할 수 없는 경계의 형식을 가집니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 선언은 불투명한 타입을 포함할 수 없습니다. 클래스는 비final 메서드 (nonfinal method) 의 반환 타입으로 불투명한 타입을 사용할 수 없습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"불투명한 타입을 반환 타입으로 사용하는 함수는 단일 기본 타입을 공유하는 값을 반환해야 합니다. 반환 타입은 함수의 제너릭 타입 파라미터의 부분인 타입을 포함할 수 있습니다. 예를 들어 함수 "},{"type":"codeVoice","code":"someFunction<T>()"},{"type":"text","text":" 는 타입 "},{"type":"codeVoice","code":"T"},{"text":" 또는 ","type":"text"},{"type":"codeVoice","code":"Dictionary<String, T>"},{"type":"text","text":" 의 값을 반환할 수 있습니다."}]},{"style":"note","type":"aside","name":"Grammar of an opaque type","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"opaque-type"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"some","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]}]},{"level":2,"anchor":"박스형-프로토콜-타입-Boxed-Protocol-Type","type":"heading","text":"박스형 프로토콜 타입 (Boxed Protocol Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"박스형 프로토콜 타입 (Boxed Protocol Type) 은 프로토콜 또는 프로토콜 혼합을 준수하는 타입을 정의하고 준수하는 타입이 프로그램 실행 중에 변경될 수 있습니다."}]},{"inlineContent":[{"text":"박스형 프로토콜 타입은 아래와 같은 형식을 가집니다:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["any <#constraint#>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"제약"}]},{"type":"text","text":" 은 프로토콜 타입, 프로토콜 혼합 타입, 프로토콜 타입의 메타타입, 또는 프로토콜 혼합 타입의 메타타입입니다."}]},{"type":"paragraph","inlineContent":[{"text":"런타임에 박스형 프로토콜 타입의 인스턴스는 제약조건에 충족하는 모든 타입의 값을 포함할 수 있습니다. 이런 동작은 불투명한 타입 (opaque type) 동작과 대조되고 컴파일 시간에 알고있는 준수하는 타입이 있습니다. 박스형 프로토콜 타입으로 사용되는 추가 간접수준을 ","type":"text"},{"type":"codeVoice","code":"boxing"},{"type":"text","text":" 이라 합니다. 박싱 (Boxing) 은 일반적으로 저장을 위한 별도의 메모리 할당과 접근에 대한 추가적인 간접수준을 필요로 하므로 런타임 시 비용이 발생합니다."}]},{"inlineContent":[{"type":"codeVoice","code":"Any"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"AnyObject"},{"text":" 타입은 이미 박스형 프로토콜 타입이므로 ","type":"text"},{"type":"codeVoice","code":"any"},{"type":"text","text":" 를 적용해도 아무런 효과가 없습니다."}],"type":"paragraph"},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"text":"Grammar of a boxed protocol type","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"boxed-protocol-type"}]},{"type":"text","text":" –> "},{"type":"strong","inlineContent":[{"code":"any","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}],"type":"paragraph"}]},{"anchor":"메타타입-타입-Metatype-Type","type":"heading","text":"메타타입 타입 (Metatype Type)","level":2},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"메타타입 타입 (metatype type)"}]},{"type":"text","text":" 은 클래스 타입, 구조체 타입, 열거형 타입, 그리고 프로토콜 타입을 포함하여 모든 타입의 타입을 나타냅니다."}]},{"type":"paragraph","inlineContent":[{"text":"클래스, 구조체, 또는 열거형 타입의 메타타입은 해당 타입의 이름 다음에 ","type":"text"},{"code":".Type","type":"codeVoice"},{"type":"text","text":" 을 붙입니다. 런타임 시 프로토콜을 준수하는 구체적인 타입이 아닌 프로토콜 타입의 메타타입은 프로토콜의 이름 다음에 "},{"type":"codeVoice","code":".Protocol"},{"text":" 을 붙입니다. 예를 들어 클래스 타입 ","type":"text"},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" 의 메타타입은 "},{"code":"SomeClass.Type","type":"codeVoice"},{"type":"text","text":" 그리고 프로토콜 "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" 의 메타타입은 "},{"type":"codeVoice","code":"SomeProtocol.Protocol"},{"type":"text","text":" 입니다."}]},{"inlineContent":[{"type":"text","text":"접미사 "},{"code":"self","type":"codeVoice"},{"type":"text","text":" 표현식을 사용하여 타입을 값으로 접근할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"SomeClass.self"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"SomeClass"},{"text":" 의 인스턴스가 아닌 ","type":"text"},{"type":"codeVoice","code":"SomeClass"},{"text":" 자체를 반환합니다. 그리고 ","type":"text"},{"code":"SomeProtocol.self","type":"codeVoice"},{"text":" 는 런타임 시 ","type":"text"},{"code":"SomeProtocol","type":"codeVoice"},{"text":" 을 준수하는 타입의 인스턴스가 아닌 ","type":"text"},{"type":"codeVoice","code":"SomeProtocol"},{"text":" 자체를 반환합니다. 다음 예제와 같이 타입의 인스턴스와 함께 ","type":"text"},{"type":"codeVoice","code":"type(of:)"},{"type":"text","text":" 함수를 호출하여 해당 인스턴스의 동적으로 런타임 타입의 값으로 접근할 수 있습니다:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class SomeBaseClass {","    class func printClassName() {","        print(\"SomeBaseClass\")","    }","}","class SomeSubClass: SomeBaseClass {","    override class func printClassName() {","        print(\"SomeSubClass\")","    }","}","let someInstance: SomeBaseClass = SomeSubClass()","\/\/ The compile-time type of someInstance is SomeBaseClass,","\/\/ and the runtime type of someInstance is SomeSubClass","type(of: someInstance).printClassName()","\/\/ Prints \"SomeSubClass\""]},{"inlineContent":[{"text":"자세한 내용은 Swift 표준 라이브러리에 ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","isActive":true,"type":"reference"},{"type":"text","text":" 을 참고 바랍니다."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"초기화 구문 표현식을 사용하여 해당 타입의 메타타입 값에서 타입의 인스턴스를 생성합니다. 클래스 인스턴스의 경우 호출되는 초기화 구문은 "},{"code":"required","type":"codeVoice"},{"type":"text","text":" 키워드로 표시거나 "},{"type":"codeVoice","code":"final"},{"type":"text","text":" 키워드로 전체 클래스를 표시해야 합니다."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class AnotherSubClass: SomeBaseClass {","    let string: String","    required init(string: String) {","        self.string = string","    }","    override class func printClassName() {","        print(\"AnotherSubClass\")","    }","}","let metatype: AnotherSubClass.Type = AnotherSubClass.self","let anotherInstance = metatype.init(string: \"some string\")"]},{"style":"note","type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"metatype-type"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Type"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Protocol"}]}]}],"name":"Grammar of a metatype type"},{"type":"heading","level":2,"text":"Any 타입 (Any Type)","anchor":"Any-타입-Any-Type"},{"inlineContent":[{"code":"Any","type":"codeVoice"},{"text":" 타입은 다른 모든 타입의 값을 포함할 수 있습니다. ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" 는 다음 타입의 인스턴스에 대해 구체적인 타입으로 사용될 수 있습니다:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"클래스, 구조체, 또는 열거형"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int.self"},{"type":"text","text":" 와 같은 메타타입"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 타입의 구성요소가 있는 튜플"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"클로저 또는 함수 타입","type":"text"}]}]}],"type":"unorderedList"},{"type":"codeListing","code":["let mixed: [Any] = [\"one\", 2, true, (4, 5.3), { () -> Int in return 6 }]"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"인스턴스에 대해 구체적인 타입으로 ","type":"text"},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 를 사용할 때 해당 프로퍼티 또는 메서드에 접근하려면 먼저 알려진 타입으로 인스턴스를 캐스팅 해야 합니다. "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 의 구체적인 타입인 인스턴스는 본래 동적 타입을 유지하고 "},{"type":"codeVoice","code":"as"},{"type":"text","text":", "},{"type":"codeVoice","code":"as?"},{"type":"text","text":", 또는 "},{"code":"as!","type":"codeVoice"},{"text":" 와 같은 타입 캐스팅 연산자 (type-cast operators) 중 하나를 사용하여 타입을 캐스팅 할 수 있습니다. 예를 들어 ","type":"text"},{"code":"as?","type":"codeVoice"},{"type":"text","text":" 을 사용하여 배열의 첫번째 객체를 "},{"code":"String","type":"codeVoice"},{"text":" 으로 조건부로 다운캐스트 합니다:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if let first = mixed.first as? String {","    print(\"The first item, '\\(first)', is a string.\")","}","\/\/ Prints \"The first item, 'one', is a string.\""]},{"type":"paragraph","inlineContent":[{"text":"캐스팅에 대한 자세한 내용은 ","type":"text"},{"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting","isActive":true,"type":"reference"},{"type":"text","text":" 을 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"code":"AnyObject","type":"codeVoice"},{"text":" 프로토콜은 ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" 타입과 유사합니다. 모든 클래스는 암시적으로 ","type":"text"},{"code":"AnyObject","type":"codeVoice"},{"type":"text","text":" 를 준수합니다. 언어에 의해 정의되는 "},{"code":"Any","type":"codeVoice"},{"type":"text","text":" 와 달리 "},{"code":"AnyObject","type":"codeVoice"},{"type":"text","text":" 는 Swift 표준 라이브러리에 의해 정의됩니다. 더 자세한 내용은 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols","isActive":true},{"text":" 과 ","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","type":"reference"},{"text":" 를 참고 바랍니다.","type":"text"}]},{"type":"aside","name":"Grammar of an Any type","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"any-type","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"Any","type":"codeVoice"}]}]}]},{"text":"Self 타입 (Self Type)","type":"heading","level":2,"anchor":"Self-타입-Self-Type"},{"type":"paragraph","inlineContent":[{"code":"Self","type":"codeVoice"},{"text":" 타입은 특정 타입이 아니라 해당 타입의 이름을 반복하거나 알지 않아도 현재 타입을 편리하게 참조할 수 있습니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 선언 또는 프로토콜 멤버 선언에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 프로토콜을 준수하는 최종 타입을 나타냅니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"구조체, 클래스, 또는 열거형 선언에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 선언에 의해 도입된 타입을 참조합니다. 타입의 멤버에 대한 선언 내에서 "},{"code":"Self","type":"codeVoice"},{"type":"text","text":" 타입은 해당 타입을 참조합니다. 클래스 선언의 멤버에서 "},{"code":"Self","type":"codeVoice"},{"text":" 는 다음을 나타낼 수 있습니다:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"메서드의 반환 타입"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"읽기전용 서브 스크립트의 반환 타입"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"읽기전용 계산된 프로퍼티의 타입","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"메서드의 본문"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"예를 들어 아래의 코드는 반환 타입이 ","type":"text"},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 인 인스턴스 메서드 "},{"code":"f","type":"codeVoice"},{"text":" 를 보여줍니다.","type":"text"}]},{"code":["class Superclass {","    func f() -> Self { return self }","}","let x = Superclass()","print(type(of: x.f()))","\/\/ Prints \"Superclass\"","","class Subclass: Superclass { }","let y = Subclass()","print(type(of: y.f()))","\/\/ Prints \"Subclass\"","","let z: Superclass = Subclass()","print(type(of: z.f()))","\/\/ Prints \"Subclass\""],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"위의 예제의 마지막 부분은 ","type":"text"},{"code":"Self","type":"codeVoice"},{"text":" 가 변수 자체의 컴파일 타임 타입 (compile-time type) ","type":"text"},{"type":"codeVoice","code":"Superclass"},{"text":" 가 아닌 ","type":"text"},{"type":"codeVoice","code":"z"},{"text":" 값의 런타임 타입 (runtime type) ","type":"text"},{"type":"codeVoice","code":"Subclass"},{"text":" 를 참조하는 것을 보여줍니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"중첩된 타입 선언 내에서 "},{"type":"codeVoice","code":"Self"},{"text":" 타입은 가장 안쪽 타입 선언에 의해 도입된 타입을 참조합니다.","type":"text"}]},{"inlineContent":[{"code":"Self","type":"codeVoice"},{"type":"text","text":" 타입은 Swift 표준 라이브러리에서 "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","overridingTitleInlineContent":[{"code":"type(of:)","type":"codeVoice"}],"overridingTitle":"type(of:)"},{"type":"text","text":" 함수와 동일한 타입을 참조합니다. 현재 타입의 멤버를 접근하기 위해 "},{"code":"Self.someStaticMember","type":"codeVoice"},{"text":" 라고 작성하는 것은 ","type":"text"},{"type":"codeVoice","code":"type(of:self).someStaticMember"},{"type":"text","text":" 로 작성하는 것과 동일합니다."}],"type":"paragraph"},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"self-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Self"}]}]}],"name":"Grammar of a Self type"},{"text":"타입 상속 절 (Type Inheritance Clause)","level":2,"type":"heading","anchor":"타입-상속-절-Type-Inheritance-Clause"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"타입 상속 절 (type inheritance clause)","type":"text"}]},{"type":"text","text":" 은 명명된 타입이 상속하는 클래스와 명명된 타입이 준수하는 프로토콜을 지정하기 위해 사용됩니다. 타입 상속 절은 콜론 ("},{"code":":","type":"codeVoice"},{"text":") 으로 시작하고 그 뒤에 타입 식별자의 리스트가 옵니다.","type":"text"}]},{"inlineContent":[{"type":"text","text":"클래스 타입은 단일 상위 클래스를 상속할 수 있고 여러개의 프로토콜을 준수할 수 있습니다. 클래스를 정의할 때 상위 클래스의 이름은 타입 식별자의 리스트에서 첫번째로 나타나야 하고 다음으로 준수하는 여러개의 프로토콜이 옵니다. 클래스가 다른 클래스를 상속하지 않으면 리스트는 대신 프로토콜로 시작할 수 있습니다. 클래스 상속에 대한 자세한 설명과 예제는 "},{"type":"reference","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Inheritance","isActive":true},{"type":"text","text":" 을 참고 바랍니다."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"다른 명명된 타입은 프로토콜의 리스트에서 상속하거나 준수할 수 있습니다. 프로토콜 타입은 여러 다른 프로토콜을 상속할 수 있습니다. 프로토콜 타입은 다른 프로토콜을 상속할 때 다른 프로토콜의 요구사항을 모으고 현재 프로토콜에서 상속되는 모든 타입은 모든 요구사항을 준수해야 합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"열거형 정의에 타입 상속 절은 프로토콜의 리스트이거나 케이스에 원시값 (raw values) 을 할당하는 열거형인 경우 해당 원시값의 타입을 지정하는 단일 명명된 타입일 수 있습니다. 타입 상속 절을 사용하여 원시값의 타입을 지정하는 열거형 정의의 예는 ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values","type":"reference"},{"text":" 을 참고 바랍니다.","type":"text"}]},{"name":"Grammar of a type inheritance clause","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-clause"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"attributes","type":"text"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-identifier","type":"text"}]},{"type":"text","text":" | "},{"inlineContent":[{"text":"attributes","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":","}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]}],"type":"paragraph"}]},{"type":"heading","anchor":"타입-추론-Type-Inference","level":2,"text":"타입 추론 (Type Inference)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 는 광범위하게 "},{"type":"emphasis","inlineContent":[{"text":"타입 추론 (type inference)","type":"text"}]},{"text":" 을 사용하므로 코드에서 많은 변수와 표현식의 타입 또는 타입의 부분을 생략할 수 있습니다. 예를 들어 ","type":"text"},{"code":"var x: Int = 0","type":"codeVoice"},{"type":"text","text":" 으로 작성하는 대신에 "},{"code":"var x = 0","type":"codeVoice"},{"type":"text","text":" 으로 타입을 완벽하게 생략하고 작성할 수 있습니다 — 컴파일러는 "},{"code":"x","type":"codeVoice"},{"text":" 를 타입 ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" 의 값으로 추론합니다. 유사하게 컨텍스트에서 전체 타입이 추론될 수 있을 때 타입의 부분을 생략할 수 있습니다. 예를 들어 "},{"code":"let dict: Dictionary = [\"A\": 1]","type":"codeVoice"},{"text":" 을 작성하면 컴파일러는 ","type":"text"},{"type":"codeVoice","code":"dict"},{"text":" 이 타입 ","type":"text"},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":" 이라고 추론합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 두 예제에서 타입 정보는 표현식 트리의 잎에서 루트까지 전달됩니다. 즉, "},{"type":"codeVoice","code":"var x: Int = 0"},{"text":" 에서 ","type":"text"},{"code":"x","type":"codeVoice"},{"text":" 의 타입은 먼저 ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":" 의 타입을 확인한 다음에 이 타입 정보를 루트 (변수 "},{"code":"x","type":"codeVoice"},{"text":") 까지 전달하여 추론합니다.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 에서 타입 정보는 루트에서 잎까지 반대로 흐를 수도 있습니다. 예를 들어 다음 예제에서 상수 "},{"type":"codeVoice","code":"eFloat"},{"type":"text","text":" 에 명시적 타입 주석 ("},{"type":"codeVoice","code":": Float"},{"text":") 은 숫자 리터럴 ","type":"text"},{"type":"codeVoice","code":"2.71828"},{"text":" 이 ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" 이 아닌 "},{"type":"codeVoice","code":"Float"},{"type":"text","text":" 타입을 유추하도록 합니다."}]},{"code":["let e = 2.71828 \/\/ The type of e is inferred to be Double.","let eFloat: Float = 2.71828 \/\/ The type of eFloat is Float."],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 에서 타입 추론은 단일 표현식 또는 구문 수준에서 동작합니다. 이것은 표현식에서 생략된 타입 또는 타입의 일부를 추론하는데 필요한 모든 정보는 표현식 또는 하위 표현식 중 하나를 타입 검사 (type-checking) 하여 접근할 수 있습니다."}]}]}],"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures":{"title":"자동 클로저 (Autoclosures)","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures","url":"\/documentation\/the-swift-programming-language-korean\/closures#%25EC%259E%2590%25EB%258F%2599-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580-Autoclosures","type":"topic"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration":{"kind":"section","abstract":[],"title":"확장 선언 (Extension Declaration)","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25ED%2599%2595%25EC%259E%25A5-%25EC%2584%25A0%25EC%2596%25B8-Extension-Declaration","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods":{"title":"다시 던지는 함수와 메서드 (Rethrowing Functions and Methods)","abstract":[],"kind":"section","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25EB%258B%25A4%25EC%258B%259C-%25EB%258D%2598%25EC%25A7%2580%25EB%258A%2594-%25ED%2595%25A8%25EC%2588%2598%25EC%2599%2580-%25EB%25A9%2594%25EC%2584%259C%25EB%2593%259C-Rethrowing-Functions-and-Methods","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals":{"kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25EC%2595%2594%25EC%258B%259C%25EC%25A0%2581%25EC%259C%25BC%25EB%25A1%259C-%25EC%2596%25B8%25EB%259E%2598%25ED%2595%2591%25EB%2590%259C-%25EC%2598%25B5%25EC%2585%2594%25EB%2584%2590-Implicitly-Unwrapped-Optionals","title":"암시적으로 언래핑된 옵셔널 (Implicitly Unwrapped Optionals)","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Extensions":{"url":"\/documentation\/the-swift-programming-language-korean\/extensions","type":"topic","role":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions","kind":"article","abstract":[{"type":"text","text":"기존 타입에 기능을 추가합니다."}],"title":"확장 (Extensions)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters":{"kind":"section","type":"topic","title":"가변 파라미터 (Variadic Parameters)","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters","url":"\/documentation\/the-swift-programming-language-korean\/functions#%25EA%25B0%2580%25EB%25B3%2580-%25ED%258C%258C%25EB%259D%25BC%25EB%25AF%25B8%25ED%2584%25B0-Variadic-Parameters","abstract":[]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values":{"abstract":[],"kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","title":"여러개의 반환값이 있는 함수 (Functions with Multiple Return Values)","url":"\/documentation\/the-swift-programming-language-korean\/functions#%25EC%2597%25AC%25EB%259F%25AC%25EA%25B0%259C%25EC%259D%2598-%25EB%25B0%2598%25ED%2599%2598%25EA%25B0%2592%25EC%259D%25B4-%25EC%259E%2588%25EB%258A%2594-%25ED%2595%25A8%25EC%2588%2598-Functions-with-Multiple-Return-Values"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters":{"kind":"section","abstract":[],"type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/functions#In-Out-%25ED%258C%258C%25EB%259D%25BC%25EB%25AF%25B8%25ED%2584%25B0-In-Out-Parameters","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters","title":"In-Out 파라미터 (In-Out Parameters)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Inheritance":{"url":"\/documentation\/the-swift-programming-language-korean\/inheritance","type":"topic","role":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Inheritance","kind":"article","abstract":[{"type":"text","text":"기능을 추가 또는 재정의 하기 위한 하위 클래스 입니다."}],"title":"상속 (Inheritance)"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays":{"kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes#%25EB%25B0%25B0%25EC%2597%25B4-Arrays","abstract":[],"title":"배열 (Arrays)"},"https://developer.apple.com/documentation/swift/2885064-type":{"title":"type(of:)","type":"link","titleInlineContent":[{"type":"codeVoice","code":"type(of:)"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values":{"title":"원시값 (Raw Values)","abstract":[],"kind":"section","url":"\/documentation\/the-swift-programming-language-korean\/enumerations#%25EC%259B%2590%25EC%258B%259C%25EA%25B0%2592-Raw-Values","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods":{"kind":"section","abstract":[],"title":"비동기 함수와 메서드 (Asynchronous Functions and Methods)","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25EB%25B9%2584%25EB%258F%2599%25EA%25B8%25B0-%25ED%2595%25A8%25EC%2588%2598%25EC%2599%2580-%25EB%25A9%2594%25EC%2584%259C%25EB%2593%259C-Asynchronous-Functions-and-Methods","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods":{"title":"함수와 메서드 던지기 (Throwing Functions and Methods)","abstract":[],"kind":"section","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25ED%2595%25A8%25EC%2588%2598%25EC%2599%2580-%25EB%25A9%2594%25EC%2584%259C%25EB%2593%259C-%25EB%258D%2598%25EC%25A7%2580%25EA%25B8%25B0-Throwing-Functions-and-Methods","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TypeCasting":{"url":"\/documentation\/the-swift-programming-language-korean\/typecasting","kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting","abstract":[{"text":"값의 런타임 타입을 정하고 타입의 정보를 제공합니다.","type":"text"}],"title":"타입 캐스팅 (Type Casting)","type":"topic","role":"article"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals":{"title":"옵셔널 (Optionals)","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25EC%2598%25B5%25EC%2585%2594%25EB%2584%2590-Optionals","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols":{"title":"클래스 전용 프로토콜 (Class-Only Protocols)","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols","url":"\/documentation\/the-swift-programming-language-korean\/protocols#%25ED%2581%25B4%25EB%259E%2598%25EC%258A%25A4-%25EC%25A0%2584%25EC%259A%25A9-%25ED%2594%2584%25EB%25A1%259C%25ED%2586%25A0%25EC%25BD%259C-Class-Only-Protocols","type":"topic"},"doc://org.swift.tsplk/documentation/TSPLK":{"title":"The Swift Programming Language (한국어)","kind":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/TSPLK","abstract":[],"url":"\/documentation\/tsplk","type":"topic","role":"collection"},"https://developer.apple.com/documentation/swift/anyobject":{"title":"AnyObject","type":"link","titleInlineContent":[{"type":"codeVoice","code":"AnyObject"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries":{"title":"딕셔너리 (Dictionaries)","kind":"section","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes#%25EB%2594%2595%25EC%2585%2594%25EB%2584%2588%25EB%25A6%25AC-Dictionaries","abstract":[],"type":"topic"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/MemorySafety":{"url":"\/documentation\/the-swift-programming-language-korean\/memorysafety","type":"topic","role":"article","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/MemorySafety","kind":"article","abstract":[{"type":"text","text":"메모리 접근할 때 충돌을 피하기위해 코드를 구조화합니다."}],"title":"메모리 안전성 (Memory Safety)"}}}